---
version: '3'

tasks:
  ansibler-compatibility-chart:
    cmds:
      - ansibler --generate-compatibility-chart
    sources:
      - .molecule-results/*.txt

  ansibler-populate-platforms:
    cmds:
      - ansibler --populate-platforms
    sources:
      - tasks/main.yml
      - .molecule-results/*.txt

  ansibler-role-dependencies:
    cmds:
      - ansibler --role-dependencies
    sources:
      - requirements.yml

  ansibler-tasks:
    deps:
      - ansibler-populate-platforms
      - ansibler-role-dependencies

  ansibler:
    deps:
      - :common:python-requirements
    cmds:
      - task: ansibler-compatibility-chart
      - task: ansibler-tasks
    preconditions:
      - sh: 'type ansibler &> /dev/null'
        msg: '`ansibler` is not installed globally. Install all the requirements by running `task common:requirements`.'
    status:
      - true

  mod-ansible-autodoc-variables:
    env:
      ROLE_VARIABLES:
        sh: jq -r '.role_variables' ansible_variables.json
      TMP:
        sh: mktemp
    cmds:
      - jq --arg vars "$ROLE_VARIABLES" '.role_variables = $vars' .variables.json > "$TMP"
      - mv "$TMP" .variables.json

  mod-ansible-autodoc:
    deps:
      - :common:python-requirements
      - :software:jq
    env:
      ACTIONS_DESCRIPTION:
        sh: jq -r '.autodoc_actions_description' .variables.json
      TAGS_DESCRIPTION:
        sh: jq -r '.autodoc_tags_description' .variables.json
      TODO_DESCRIPTION:
        sh: jq -r '.autodoc_todo_description' .variables.json
      VARIABLES_DESCRIPTION:
        sh: jq -r '.autodoc_variables_description' .variables.json
    cmds:
      - mod-ansible-autodoc --actions-title "## Features" --actions-description "$ACTIONS_DESCRIPTION"
        --tags-title "### Tags" --tags-description "$TAGS_DESCRIPTION" --todo-title "### TODO"
        --todo-description "$TODO_DESCRIPTION" --variables-title "## Variables" --variables-description
        "$VARIABLES_DESCRIPTION"
      - task: mod-ansible-autodoc-variables
      - mkdir -p .autodoc
      - mv ansible_actions.md ansible_tags.md ansible_todo.md ansible_variables.json ansible_variables.md .autodoc
    sources:
      - 'tasks**/*.yml'
      - '.autodoc/*'
    preconditions:
      - sh: 'type mod-ansible-autodoc &> /dev/null'
        msg: 'The Python package `mod-ansible-autodoc` is missing. Ensure all the requirements are installed
          by running `task common:requirements`. Also, ensure `mod-ansible-autodoc` is included in the `requirements.txt`
          file.'

  populate-collection:
    deps:
      - :software:yq
    env:
      COLLECTIONS:
        sh: yq eval '.collections' requirements.yml
      REFERENCES:
        sh: grep -Ril "{{.KEY}}" ./tasks || true
    cmds:
      - |
        if [[ ! "$COLLECTIONS" =~ "{{.KEY}}" ]] && [ "$REFERENCES" ]; then
          yq eval -i -P '.collections = .collections + {{.VAL}}' requirements.yml
        fi
      - task: :fix:yml-dashes
        vars:
          CLI_ARGS: requirements.yml
    status:
      - '[[ "$COLLECTIONS" =~ "{{.KEY}}" ]] || [ ! "$REFERENCES" ]'

  populate-dependencies:
    desc: Attempt to automatically populate meta/main.yml and requirements.yml
    summary: |
      $ Automatically populate meta/main.yml and requirements.yml

      A role can sometimes have dependencies that need to be installed prior to being run (e.g. most
      roles in Ansible >2.9 need the `community.general` collection installed). Roles also sometimes
      need other roles to run before they are run (e.g. a task that installs a Node.js package needs
      the Node.js installer to run first). This task will scan for common dependencies by doing a text
      search for a handful of common strings. It will then attempt to automatically populate
      `meta/main.yml` and the `requirements.yml`.

      Items it attempts to auto-populate for:
        * chocolatey.chocolatey        * community.general.gem
        * community.general            * community.general.npm
        * community.general.homebrew   * community.general.snap
    cmds:
      - task: populate-collection
        vars:
          KEY: chocolatey.chocolatey
          VAL: '{"name": "chocolatey.chocolatey", "source": "https://galaxy.ansible.com"}'
      - task: populate-collection
        vars:
          KEY: community.general
          VAL: '{"name": "community.general", "source": "https://galaxy.ansible.com"}'
      - task: populate-dependency
        vars:
          KEY: community.general.homebrew
          ROLE: professormanhattan.homebrew
          VAL: '{"role": "professormanhattan.homebrew", "when": "ansible_os_family == \"Darwin\""}'
      - task: populate-dependency
        vars:
          KEY: community.general.npm
          ROLE: professormanhattan.nodejs
          VAL: '{"role": "professormanhattan.nodejs"}'
      - task: populate-dependency
        vars:
          KEY: community.general.gem
          ROLE: professormanhattan.ruby
          VAL: '{"role": "professormanhattan.ruby"}'
      - task: populate-dependency
        vars:
          KEY: community.general.snap
          ROLE: professormanhattan.snapd
          VAL: '{"role": "professormanhattan.snapd", "when": "ansible_system == \"Linux\""}'
      - task: sync-requirements
    sources:
      - meta/main.yml
      - requirements.yml
      - tasks/**/*.yml

  populate-dependency:
    deps:
      - :software:yq
    env:
      DEPENDENCIES:
        sh: yq eval '.dependencies' meta/main.yml
      REFERENCES:
        sh: grep -Ril "{{.KEY}}" ./tasks || true
    cmds:
      - |
        if [[ ! "$DEPENDENCIES" =~ "{{.ROLE}}" ]] && [ "$REFERENCES" ]; then
          yq eval -i -P '.dependencies = .dependencies + {{.VAL}}' meta/main.yml
        fi
      - task: :fix:yml-dashes
        vars:
          CLI_ARGS: meta/main.yml
    status:
      - '[[ "$DEPENDENCIES" =~ "{{.ROLE}}" ]] || [ ! "$REFERENCES" ]'

  populate-meta:
    deps:
      - :npm:prettier-package-json
      - :software:jq
    vars:
      DESCRIPTION:
        sh: yq eval '.galaxy_info.description' meta/main.yml
    env:
      TMP:
        sh: mktemp
    cmds:
      - jq --arg a "{{.DESCRIPTION}}" --arg b "{{.GALAXY_ROLE_NAME}}" '.blueprint.description = $a | .blueprint.slug = $b' package.json > "$TMP"
      - mv "$TMP" package.json
      - prettier-package-json --write package.json
    preconditions:
      - sh: test -f meta/main.yml
        msg: "The 'meta/main.yml' file is missing. A properly filled out 'meta/main.yml' file is required for the
          update process. See https://gitlab.com/megabyte-labs/ansible-roles/androidstudio/-/blob/master/meta/main.yml
          for a good example of one."
      - sh: '[[ "{{.DESCRIPTION}}" != "null" ]]'
        msg: "The 'meta/main.yml' file has a null value for the 'galaxy_info.description' key. Ensure the description
          is populated in 'meta/main.yml'. See https://gitlab.com/megabyte-labs/ansible-roles/androidstudio/-/blob/master/meta/main.yml
          for an example."
      - sh: '[[ "{{.GALAXY_ROLE_NAME}}" != "null" ]]'
        msg: "The 'meta/main.yml' file has a null value for the 'galaxy_info.role_name' key. Ensure the role name is
          populated in 'meta/main.yml'. See https://gitlab.com/megabyte-labs/ansible-roles/androidstudio/-/blob/master/meta/main.yml
          for an example."

  symlink:
    desc: Symlink the current role to ~/.ansible/roles/{{.GALAXY_NAMESPACE}}.{{.GALAXY_ROLE_NAME}}
    summary: |
      $ Symlink this role to ~/.ansible/roles/{{.GALAXY_NAMESPACE}}.{{.GALAXY_ROLE_NAME}}

      Roles are sometimes referred to by their folder name (which ideally is also the role_name in
      the meta/main.yml file) and they are sometimes referred to by their Ansible Galaxy name which
      has the namespace prepended (e.g. {{.GALAXY_NAMESPACE}}.role_name). In order to make sure Ansible
      can find the role in both cases, a symlink in ~/.ansible/roles that points to the folder needs
      to be created.
    vars:
      SYMLINK:
        sh: readlink "$HOME/.ansible/roles/professormanhattan.androidstudio"
    cmds:
      - mkdir -p "$HOME/.ansible/roles"
      - rm -f "$HOME/.ansible/roles/{{.GALAXY_NAMESPACE}}.{{.GALAXY_ROLE_NAME}}"
      - ln -s "$PWD" "~/.ansible/roles/{{.GALAXY_NAMESPACE}}.{{.GALAXY_ROLE_NAME}}"
    status:
      - test -d "$HOME/.ansible/roles/professormanhattan.androidstudio"
      - '[ "{{.SYMLINK}}" == "$PWD" ]'

  sync-requirements:
    deps:
      - :software:jq
      - :software:yq
    env:
      ROLES:
        sh: yq eval '.roles' requirements.yml
      TMP_SYNC:
        sh: mktemp
    cmds:
      - yq eval -j '.dependencies' meta/main.yml > "$TMP_SYNC"
      - |
        jq -rc '.[] .role' "$TMP_SYNC" | while read ROLE_NAME; do
          if [[ ! "$ROLES" =~ "$ROLE_NAME" ]]; then
            ROLE_NAME="$ROLE_NAME" yq eval -i -P '.roles = .roles + {"name": env(ROLE_NAME)}' requirements.yml
          fi
        done
      - task: :fix:yml-dashes
        vars:
          CLI_ARGS: requirements.yml

  update-galaxy-id:
    vars:
      HAS_PROJECT_ID:
        sh: jq -e 'has("blueprint.ansible_galaxy_project_id")' package.json || true
    env:
      PROJECT_ID:
        sh: '(ansible-galaxy info "{{.GALAXY_NAMESPACE}}.{{.GALAXY_ROLE_NAME}}" | grep -E "id: [0-9]" | awk {"print $2"}) 2> /dev/null || true'
      TMP:
        sh: mktemp
    cmds:
      - |
        if [ "$PROJECT_ID" ]; then
          jq --arg a "${PROJECT_ID}" '.blueprint.ansible_galaxy_project_id = $a' package.json > "$TMP"
          mv "$TMP" package.json
        fi
    status:
      - '[[ "{{.HAS_PROJECT_ID}}" == "true" ]]'

  update-variables:
    deps:
      - :software:jq
      - :software:yq
    env:
      DESCRIPTION:
        sh: yq e '.galaxy_info.description' meta/main.yml
      DESCRIPTION_FIRST_LETTER:
        sh: echo ${DESCRIPTION:0:1} | tr '[A-Z]' '[a-z]'
      DESCRIPTION_LOWERCASE:
        sh: echo "${DESCRIPTION_FIRST_LETTER}${DESCRIPTION:1}"
      DESCRIPTION_SUBHEADER:
        sh: echo "An Ansible role that ${LOWERCASE_DESCRIPTION}"
      DESCRIPTION_ALT:
        sh: echo "This repository is the home of an [Ansible](https://www.ansible.com/) role that ${LOWERCASE_DESCRIPTION}."
      GALAXY_INFO:
        sh: yq e -j '.galaxy_info' meta/main.yml
      TMP:
        sh: mktemp
    cmds:
      - jq -S --arg subheader "$DESCRIPTION_SUBHEADER" --arg alt "$DESCRIPTION_ALT" --arg galaxyinfo "$GALAXY_INFO"
        '.subheader_description = $subheader | .alternative_description = $alt | .galaxy_info = ($galaxyinfo | fromjson)' .variables.json > "$TMP"
      - mv "$TMP" .variables.json
    preconditions:
      - sh: 'type jq &> /dev/null'
        msg: 'jq is not installed! You can install it by running `task software:jq`.'
      - sh: 'type yq &> /dev/null'
        msg: 'yq is not installed! You can install it by running `task software:yq`.'
      - sh: 'test -f meta/main.yml'
        msg: 'The `meta/main.yml` file is missing. A properly populated `meta/main.yml` is required. You can find an
          example of one at https://github.com/ProfessorManhattan/ansible-snapd.'
      - sh: test -f .variables.json
        msg: 'The `.variables.json` file is missing!'
    sources:
      - '.common/variables.{{.REPOSITORY_SUBTYPE}}.json'
      - meta/main.yml
      - package.json
