---
version: '3'

tasks:
{{#if hbs.role}}
  autopopulate-ansible-dependencies:
    env:
      COLLECTIONS:
        sh: yq eval '.collections' requirements.yml
      DEPENDENCIES:
        sh: yq eval '.dependencies' meta/main.yml
    cmds:
      - task: autopopulate-ansible-collection
        vars:
          KEY: chocolatey.chocolatey
          VAL: '{"name": "chocolatey.chocolatey", "source": "https://galaxy.ansible.com"}'
      - task: autopopulate-ansible-collection
        vars:
          KEY: community.general
          VAL: '{"name": "community.general", "source": "https://galaxy.ansible.com"}'
      - task: autopopulate-ansible-dependency
        vars:
          KEY: community.general.homebrew
          VAL: '{"role": "professormanhattan.homebrew", "when": "ansible_os_family == \"Darwin\""}'
      - task: autopopulate-ansible-dependency
        vars:
          KEY: community.general.npm
          VAL: '{"role": "professormanhattan.nodejs"}'
      - task: autopopulate-ansible-dependency
        vars:
          KEY: community.general.gem
          VAL: '{"role": "professormanhattan.ruby"}'
      - task: autopopulate-ansible-dependency
        vars:
          KEY: community.general.snap
          VAL: '{"role": "professormanhattan.snapd", "when": "ansible_system == \"Linux\""}'

  autopopulate-ansible-collection:
    env:
      REFS:
        sh: grep -Ril "\{{.KEY}}" ./tasks
    cmds:
      - yq eval -i -P '.collections = .collections + \{{.VAL}}' requirements.yml
    status:
      - '[ ! "$REFS" ]'
      - '[[ ! "$COLLECTIONS" =~ "\{{.KEY}}" ]]'

  autopopulate-ansible-dependency:
    env:
      REFS:
        sh: grep -Ril "\{{.KEY}}" ./tasks
    cmds:
      - yq eval -i -P '.dependencies = .dependencies + \{{.VAL}}' meta/main.yml
    status:
      - '[ ! "$REFS" ]'
      - '[[ ! "$DEPENDENCIES" =~ "\{{.KEY}}" ]]'

  autopopulate-ansible-requirements:
    env:
      REFS:
        sh: yq eval '.roles' requirements.yml
      TMP:
        sh: mktemp
    cmds:
      - yq eval -j '.dependencies' meta/main.yml > "$TMP"
      - |
        jq -rc '.[] .role' "$TMP" | while read ROLE_NAME; do
          if [[ ! "$REFS" =~ "$ROLE_NAME" ]]; then
            yq eval -i -P '.roles = .roles + {"name": env(ROLE_NAME)}' requirements.yml
            (echo "---" && cat requirements.yml) > requirements.yml
          fi
        done

{{/if}}
  clean:
    desc: Removes optional folders that are cached during various tasks
    summary: |
      $ Clean the project and remove all optional caches

      This task will remove all the unnecessary files that are downloaded, generated, and
      cached during various build steps. This task is used by the `task common:reset` task
      which will re-generate the project from scratch. Ideally, this task and the reset task
      should never be necessary. The `common:update` task should be used instead.
    vars:
      RANDOM_STRING:
        sh: openssl rand -hex 14
    cmds:
      - bash .common/log log "Cleaning up the project by removing caches etc."
      - rm .variables.json 2> /dev/null
      - mv .autodoc /tmp/\{{.RANDOM_STRING}}-autodoc 2> /dev/null
      - mv .task /tmp/\{{.RANDOM_STRING}}-task 2> /dev/null
      - mv .venv /tmp/\{{.RANDOM_STRING}}-venv 2> /dev/null
      - mv node_modules /tmp/\{{.RANDOM_STRING}}-node_modules 2> /dev/null
      - mkdir /tmp/\{{.RANDOM_STRING}}-empty
      - |
        for TMP_FILE in autodoc task venv node_modules; do
          if [ -f "/tmp/\{{.RANDOM_STRING}}-$TMP_FILE" ] || [ -d "/tmp/\{{.RANDOM_STRING}}-$TMP_FILE" ]; then
            rsync -a --delete /tmp/\{{.RANDOM_STRING}}-empty "/tmp/\{{.RANDOM_STRING}}-$TMP_FILE" &
          fi
        done

  commit:
    deps: [nodejs-dependencies, python-requirements]
    desc: Lint staged files, report spelling errors, and open a _required_ commit dialoge
    summary: |
      $ Commit code

      This task will perform linting and auto-fixing on the files that have been staged in
      git (i.e. the files that were added with `git add --all`). It will then report possible
      spelling errors that you may choose to fix. Then, it opens a _required_ interactive commit
      questionnaire that will help you make better commits that are compatible with software
      that generates the CHANGELOG.md.

      It is very important that you use this task to commit rather than the conventional approach
      using `git commit -m`. However, if you really need to, you can add the flag `--no-verify`
      to your regular `git commit -m` command to bypass the pre-commit hook.
    cmds:
      - bash .common/log log "Running pre-commit hook"
      - . ./.husky/pre-commit
      - bash .common/log log "Initiating the commit dialog"
      - npm run commit -- --no-verify

  markdown-link-check:
    deps: [nodejs-dependencies]
    desc: Scan markdown files for broken links
    summary: |
      $ Report any broken links in the files that end with .md

      This task uses the npm package called `markdown-link-check` to scan all the links
      and then report which ones are broken.

      For more information on `markdown-link-check`, see the following page:
      https://github.com/tcort/markdown-link-check
    cmds:
      - bash .common/log log "Checking for broken links in markdown files"
      - npm run misc:markdown-links

  prepare-release:
    deps: [nodejs-dependencies]
    desc: Ensure the project has upstream changes, lint, and then update the version
    summary: |
      $ Prepare a new release

      This task performs the following tasks in order:
      (1) Ensures the project is up-to-date with the latest upstream changes
      (2) Lints the project with all available linters
      (3) Updates the version of the project in the `package.json` file
      (4) Add the appropriate details to the CHANGELOG.md file
    cmds:
      - task: update
      - task: :lint:all
{{#if hbs.packer}}
      - task: :test:packer
{{/if}}
{{#if hbs.vagrant}}
      - task: :test:vagrant
{{/if}}
      - npm run version

  requirements:
    desc: Ensure all the dependencies are installed (Node.js, Python, etc.)
    summary: |
      $ Ensure dependencies are installed

      This task ensures that packages in various languages (Node.js, Python, etc.) are installed.
      At the very minimum, it will install the Node.js requirements by running `npm install` and
      then install the Python requirements by running `pip3 install -r requirements` after
      initiating a `virtualenv`. In some types of projects, additional types of requirements are
      installed (e.g. Ansible projects also install Ansible Galaxy requirements).
    deps: [nodejs-dependencies, nodejs-global-dependencies, python-requirements{{#if hbs.ansible}}, galaxy-requirements{{/if}}]

{{#if hbs.ansible}}
  galaxy-requirements:
    deps: [python-requirements]
    cmds:
      - |
        if [ "${container:=}" != 'docker' ]; then
          bash .common/log log "Running `ansible-galaxy install -r requirements.yml --ignore-errors`"
          ansible-galaxy install -r requirements.yml --ignore-errors
          bash .common/log success "Successfully installed Ansible Galaxy requirements"
        fi
    sources:
      - requirements.yml
    preconditions:
      - sh: "test -f requirements.yml"
        msg: "The requirements.yml file is missing! It should be present even if it is empty (which should almost never be the case)."

{{/if}}
{{#if hbs.packer}}
  populate-packer-descriptions:
    deps:
      - :software:jq
    vars:
      DESCRIPTION_TEMPLATE:
        sh: jq -r '.description_template' .variables.json
      VERSION_DESCRIPTION:
        sh: jq -r '.version_description' .variables.json
    env:
      TMP:
        sh: mktemp
    cmds:
      - jq --arg a "\{{.DESCRIPTION_TEMPLATE}}" --arg b "\{{.VERSION_DESCRIPTION}}" '.variables.description = $a | .variables.version_description = $b'
          template.json > "$TMP"
      - mv "$TMP" template.json
    sources:
      - template.json

{{/if}}
  reset:
    desc: Resets the project by removing all caches and updating the project
    summary: |
      $ Reset the project and then update it

      This task is intended to be used when the `common:update` task is having trouble
      or when breaking changes are made to the build tools. Use this task if you are
      having trouble with other tasks that are dependent on stale caches. Unlike
      `task common:hard-reset`, this will not remove uncommitted work (assuming your
      work does not reside in folders ignored by the `.gitignore` file).
    cmds:
      - task: clean
      - task: update

  reset-force:
    deps:
      - software:git
    desc: "Aggressively reset the project (WARNING: This will wipe uncommitted work)"
    summary: |
      $ Aggressively reset the project

      If using `task common:reset` does not fix your issues, you can run this task
      to completely wipe out uncommitted work, clear all the caches, and sync
      with the master branch of both this project and its upstream repositories.
    cmds:
      - git reset --hard HEAD
      - git clean -fxd :/
      - git checkout master
      - git pull origin master --no-rebase
      - bash .start.sh

  nodejs-dependencies:
    deps:
      - :software:node
    cmds:
      - |
        if [ "${container:=}" != 'docker' ]; then
          bash .common/log info "Running `npm install`"
          npm install
          npm audit fix --force
          bash .common/log success "Successfully ran `npm install`"
        fi
    sources:
      - package.json
      - package-lock.json
    status:
      - test -d node_modules
    preconditions:
      - sh: "test -f package.json"
        msg: "The package.json file appears to be missing!"

  nodejs-global-dependencies:
    deps: [npm-hbs, npm-prettier, npm-prettier-package-json, npm-readme{{#if hbs.dockerfile}}, snyk{{/if}}]
    status:
      - '[[ "${container:=}" == "docker" ]]'

  npm-install:
    deps:
      - :software:node
    cmds:
      - |
        if [ "${container:=}" != 'docker' ]; then
          bash .common/log info "Running `npm install -g \{{.NPM_PACKAGE}}`"
          npm install -g \{{.NPM_PACKAGE}}
          bash .common/log success "`The npm \{{.NPM_PACKAGE}}` package is globally installed"
        fi
    status:
      - type \{{.NPM_PACKAGE_BIN}} &> /dev/null

  npm-hbs:
    cmds:
      - task: npm-install
        vars:
          NPM_PACKAGE: hbs-cli
          NPM_PACKAGE_BIN: hbs

  npm-prettier:
    cmds:
      - task: npm-install
        vars:
          NPM_PACKAGE: prettier
          NPM_PACKAGE_BIN: prettier

  npm-prettier-package-json:
    cmds:
      - task: npm-install
        vars:
          NPM_PACKAGE: prettier-package-json
          NPM_PACKAGE_BIN: prettier-package-json

  npm-readme:
    cmds:
      - task: npm-install
        vars:
          NPM_PACKAGE: '@appnest/readme'
          NPM_PACKAGE_BIN: readme

  npm-snyk:
    cmds:
      - task: npm-install
        vars:
          NPM_PACKAGE: snyk
          NPM_PACKAGE_BIN: snyk

  python-requirements:
    deps:
      - :software:python
    cmds:
      - task: python-requirements-venv
      - task: python-requirements-venv-activate
      - task: python-requirements-pip
    status:
      - '[[ "${container:=}" == "docker" ]]'

  python-requirements-venv:
    vars:
      RANDOM_STRING:
        sh: openssl rand -hex 14
    cmds:
      - task: python-virtualenv
      - |
        if [ -d .venv ]; then
          mv .venv /tmp/\{{.RANDOM_STRING}}-venv2 2> /dev/null
          mkdir /tmp/\{{.RANDOM_STRING}}-empty
          rsync -a --delete /tmp/\{{.RANDOM_STRING}}-empty /tmp/\{{.RANDOM_STRING}}-venv2 &
        fi
      - virtualenv .venv
    status:
      - test -f .venv/bin/activate

  python-requirements-venv-activate:
    cmds:
      - . .venv/bin/activate
    preconditions:
      - sh: test -f .venv/bin/activate
        msg: "`.venv/bin/activate` is missing!"

  python-requirements-pip:
    cmds:
      - pip3 install -r requirements.txt
    sources:
      - requirements.txt
    preconditions:
      - sh: "test -f requirements.txt"
        msg: "The requirements.txt file is missing!"

  python-virtualenv:
    cmds:
      - pip3 install virtualenv
    status:
      - type virtualenv &> /dev/null

  shell:
    deps:
      - :software:docker
    desc: Start a terminal session using Docker with any Linux operating system
    summary: |
      $ Start a Docker terminal session

      Use Docker to run commands on nearly any operating system. The operating
      systems are all stock distros with systemd added.

      Example opening an interactive prompt:
      > task shell

      Example of directly shelling into a container:
      > task shell -- ubuntu-21.04

      Available operating systems:
        * archlinux   * debian-9     * fedora-34      * ubuntu-21.04
        * centos-7    * debian-10    * ubuntu-18.04
        * centos-8    * fedora-33    * ubuntu-20.04
    vars:
      WORKDIR:
        sh: basename $PWD
    cmds:
      - |
        if [ ! -z "\{{.CLI_ARGS}}" ]; then
          docker run --cap-drop=ALL -it -v "$PWD:/\{{.WORKDIR}}" -w /\{{.WORKDIR}} --rm megabytelabs/ansible-molecule-\{{.CLI_ARGS}}:latest /bin/bash
        fi
      - task: shell-prompt
    preconditions:
      - sh: "type docker &> /dev/null"
        msg: "Docker is not installed! Install it by running `task software:docker`."

    shell-prompt:
      deps:
        - :software:node
      env:
        OS_CHOICE:
          sh: node .common/scripts/prompts/shell.js
      cmds:
        - |
          if [ -z "\{{.CLI_ARGS}}" ] && [ ! -z "$OS_CHOICE" ]; then
            docker run --cap-drop=ALL -it -v "$PWD:/\{{.WORKDIR}}" -w /\{{.WORKDIR}} --rm "megabytelabs/ansible-molecule-${OS_CHOICE}:latest" /bin/bash
          fi
      preconditions:
        - sh: "type node &> /dev/null"
          msg: "Node.js is not installed! Install it by running `task software:node`."
      status:
        - '[[ ! -z "\{{.CLI_ARGS}}" ]]'

  spelling:
    deps:
      - :software:git
      - :software:node
    desc: Checks for spelling errors in staged files
    summary: |
      $ Check for spelling errors in staged files

      Use cspell to check for possible spelling errors using the configuration stored in `.common/.cspell.json`.

      This task is utilized by the pre-commit hook. For more information about cspell, see:
      https://www.npmjs.com/package/cspell

      Although this task only analyzes staged files, you can manually run cspell, for example, on all JavaScript
      files by running:
      > npx cspell '**/*.js'
    env:
      STAGED_FILES:
        sh: git diff --cached --name-only
    cmds:
      - npx cspell --no-summary --no-progress --show-context --no-must-find-files --config .common/.cspell.json "$STAGED_FILES" || true
    preconditions:
      - sh: "git diff --cached --name-only"
        msg: "Cannot perform a spell check because there are no staged files"

  update:
    deps: [update-common, {{#if hbs.packer}}update-latestos, {{/if}}{{#if hbs.role}}update-ansible-galaxy-id, autopopulate-ansible-dependencies, {{/if}}update-project]
    desc: Refresh the project with the latest upstream code and ensure blueprint data has propagated
    cmds:
      - task: update-start
      - task: update-all
      - task: update-finish
      - bash .common/log success "Successfully updated the project with the latest upstream changes"

  update-start:
    deps: [requirements, update-start-sh, update-taskfile, update-variables]

  update-common:
    deps:
      - :software:git
    cmds:
      - cd .common
      - git reset --hard HEAD
      - git pull origin master --ff-only
      - cd ..
    preconditions:
      - sh: "type git &> /dev/null"
        msg: "git is not installed! You can install it by running `task software:git`."

  update-finish:
    deps: [{{#if hbs.dockerfile}}update-docker-labels{{/if}}]

  update-project:
    cmds:
      - git pull origin master --no-rebase

  update-start-sh:
    cmds:
      - cp .common/.start.sh .start.sh
    sources:
      - .common/start.sh

  update-taskfile:
    cmds:
      - cp .common/files-\{{.REPOSITORY_SUBTYPE}}/Taskfile.yml Taskfile.yml
    sources:
      - .common/files-\{{.REPOSITORY_SUBTYPE}}/Taskfile.yml

  update-variables:
    deps:
      - :software:jq
    env:
      BLUEPRINT_DATA:
        sh: jq -r '.blueprint' package.json
      TMP:
        sh: mktemp
    vars:
      COMMON_JSON: ".common/common.\{{.REPOSITORY_SUBTYPE}}.json"
    cmds:
      - jq -S --arg blueprint "$BLUEPRINT_DATA" '. = . * ($blueprint | fromjson)' ".common/variables.\{{.REPOSITORY_SUBTYPE}}.json" > "$TMP"
      - mv "$TMP" .variables.json
{{#if hbs.packer}}
      - task: update-variables-packer
{{/if}}
{{#if hbs.role}}
      - task: update-variables-role
{{/if}}
    sources:
      - ".common/variables.\{{.REPOSITORY_SUBTYPE}}.json"
      - package.json
    preconditions:
      - sh: "type jq &> /dev/null"
        msg: "jq is not installed! You can install it by running `task software:jq`."
      - sh: "type yq &> /dev/null"
        msg: "yq is not installed! You can install it by running `task software:yq`."

{{#if hbs.packer}}
  update-variables-packer:
    deps:
      - :software:jq
    vars:
      ISO_VERSION:
        sh: jq -r '.variables.iso_version' template.json
      MAJOR_VERSION:
        sh: cut -d '.' -f 1 <<< \{{.ISO_VERSION}}
      MINOR_VERSION:
        sh: cut -d '.' -f 2 <<< \{{.ISO_VERSION}}
    env:
      TEMPLATE_JSON:
        sh: jq -r '.' template.json
      TMP:
        sh: mktemp
    cmds:
      - jq -S --arg templatejson "$TEMPLATE_JSON" '.template_json = ($templatejson | fromjson)' .variables.json > "$TMP"
      - mv "$TMP" .variables.json
      - |
        if [[ '\{{OS}}' == 'darwin' ]]; then
          sed -i .bak "s^MAJOR_VERSION^\{{.MAJOR_VERSION}}^g" .variables.json && rm .variables.json.bak
          sed -i .bak "s^MINOR_VERSION^\{{.MINOR_VERSION}}^g" .variables.json && rm .variables.json.bak
          sed -i .bak "s^ISO_VERSION^\{{.ISO_VERSION}}^g" .variables.json && rm .variables.json.bak
        elif [[ '\{{OS}}' == 'linux' ]]; then
          sed -i "s^MAJOR_VERSION^\{{.MAJOR_VERSION}}^g" .variables.json
          sed -i "s^MINOR_VERSION^\{{.MINOR_VERSION}}^g" .variables.json
          sed -i "s^ISO_VERSION^\{{.ISO_VERSION}}^g" .variables.json
        fi
    sources:
      - template.json
      - .variables.json
    preconditions:
      - sh: test -f template.json
        msg: "A `template.json` file is not present. This project uses values stored in `template.json` to generate certain
          meta artifacts. Please add a `template.json`. You can find an example of one in this repository:
          https://gitlab.com/megabyte-labs/packer/ubuntu-desktop"
      - sh: test -f .variables.json
        msg: "The `.variables.json` file is missing!"

{{/if}}
{{#if hbs.role}}
  update-variables-role:
    deps:
      - :software:jq
      - :software:yq
    env:
      DESCRIPTION:
        sh: yq e '.galaxy_info.description' meta/main.yml
      DESCRIPTION_FIRST_LETTER:
        sh: echo ${DESCRIPTION:0:1} | tr '[A-Z]' '[a-z]'
      DESCRIPTION_LOWERCASE:
        sh: echo "${DESCRIPTION_FIRST_LETTER}${DESCRIPTION:1}"
      DESCRIPTION_SUBHEADER:
        sh: echo "An Ansible role that ${LOWERCASE_DESCRIPTION}"
      DESCRIPTION_ALT:
        sh: echo "This repository is the home of an [Ansible](https://www.ansible.com/) role that ${LOWERCASE_DESCRIPTION}."
      GALAXY_INFO:
        sh: yq e -j '.galaxy_info' meta/main.yml
      TMP:
        sh: mktemp
    cmds:
      - jq -S --arg subheader "$DESCRIPTION_SUBHEADER" --arg alt "$DESCRIPTION_ALT" --arg galaxyinfo "$GALAXY_INFO"
          '.subheader_description = $subheader | .alternative_description = $alt | .galaxy_info = ($galaxyinfo | fromjson)' .variables.json > "$TMP"
      - mv "$TMP" .variables.json
    preconditions:
      - sh: "type jq &> /dev/null"
        msg: "jq is not installed! You can install it by running `task software:jq`."
      - sh: "type yq &> /dev/null"
        msg: "yq is not installed! You can install it by running `task software:yq`."
      - sh: "test -f meta/main.yml"
        msg: "The `meta/main.yml` file is missing. A properly populated `meta/main.yml` is required. You can find an
          example of one at https://github.com/ProfessorManhattan/ansible-snapd."
      - sh: test -f .variables.json
        msg: "The `.variables.json` file is missing!"
    sources:
      - ".common/variables.\{{.REPOSITORY_SUBTYPE}}.json"
      - meta/main.yml
      - package.json

{{/if}}
  update-all:
    deps: [{{#if hbs.packer}}populate-packer-descriptions, {{/if}}update-contributing, update-readme{{#if hbs.role}}-role{{/if}}, update-files]

{{#if hbs.dockerfile}}
  update-docker-labels:
    deps:
      - :software:jq
    vars:
      GROUP_URL: {{repository.group.dockerfile}}
    env:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      SLUG:
        sh: jq -r '.slug' .variables.json
    cmds:
      - |
        if ! grep 'org.opencontainers.image.documentation' Dockerfile; then
          echo 'ARG BUILD_DATE' >> Dockerfile
          echo 'ARG REVISION' >> Dockerfile
          echo 'ARG VERSION' >> Dockerfile
          echo '' >> Dockerfile
          echo 'LABEL maintainer="{{organization}} <{{email.help}}>"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.authors="{{docker_label_authors}}"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.created=$BUILD_DATE' >> Dockerfile
          echo 'LABEL org.opencontainers.image.description="[[ Injected by running `task update` ]]"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.documentation="[[ Injected by running `task update` ]]"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.licenses="{{license}}"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.revision=$REVISION' >> Dockerfile
          echo 'LABEL org.opencontainers.image.source="[[ Injected by running `task update` ]]"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.url="{{link.home}}"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.vendor="{{organization}}"' >> Dockerfile
          echo 'LABEL org.opencontainers.image.version=$VERSION' >> Dockerfile
          echo 'LABEL space.megabyte.type="\{{.REPOSITORY_SUBTYPE}}"' >> Dockerfile
          echo '' >> Dockerfile
        fi
      # yamllint disable rule:line-length
      - |
        if [[ '\{{OS}}' == 'darwin' ]]; then
          sed -i .bak "s^.*org.opencontainers.image.description.*^LABEL org.opencontainers.image.description=${DESCRIPTION}^g" Dockerfile && rm Dockerfile.bak
          sed -i .bak "s^.*org.opencontainers.image.documentation.*^LABEL org.opencontainers.image.documentation=\"\{{.GROUP_URL}}/\{{.REPOSITORY_SUBTYPE}}/${SLUG}/-/blob/master/README.md\"^g" Dockerfile && rm Dockerfile.bak
          sed -i .bak "s^.*org.opencontainers.image.source.*^LABEL org.opencontainers.image.source=\"\{{.GROUP_URL}}/\{{.REPOSITORY_SUBTYPE}}/${SLUG}.git\"^g" Dockerfile && rm Dockerfile.bak
        elif [[ '\{{OS}}' == 'linux' ]]; then
          sed -i "s^.*org.opencontainers.image.description.*^LABEL org.opencontainers.image.description=${DESCRIPTION}^g" Dockerfile
          sed -i "s^.*org.opencontainers.image.documentation.*^LABEL org.opencontainers.image.documentation=\{{.GROUP_URL}}/\{{.REPOSITORY_SUBTYPE}}/${SLUG}/-/blob/master/README.md\"^g" Dockerfile
          sed -i "s^.*org.opencontainers.image.source.\*^LABEL org.opencontainers.image.source=\{{.GROUP_URL}}/\{{.REPOSITORY_SUBTYPE}}/${SLUG}.git\"^g" Dockerfile
        fi
      # yamllint enable rule:line-length
    sources:
      - .variables.json
      - Dockerfile
      - package.json
    preconditions:
      - sh: test -f Dockerfile
        msg: "A `Dockerfile` is not present in the root of this project!"
      - sh: test -f .variables.json
        msg: "The `.variables.json` file is not present in the root of this project!"
      - sh: test -f package.json
        msg: "The `package.json` file is not present in the root of this project!"

{{/if}}
  update-modules:
    deps:
      - :software:git
    desc: Ensure all submodules in the `.modules/` folder are updated
    summary: |
      $ Ensure all submodules in `.modules/` are updated

      Some of our projects include submodules. These submodules are generally
      stored in the `.modules/` folder in the root of the project. Some projects
      might symlink files to one of the submodules stored in the `.modules/` folder.
      If you are ok with the risk, you can use this task to update all the submodules
      to the latest on the remote's master branch.
    cmds:
      - |
        for SUBMODULE_PATH in .modules/*; do
          cd $SUBMODULE_PATH
          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
          git reset --hard HEAD
          git checkout "$DEFAULT_BRANCH"
          git pull origin "$DEFAULT_BRANCH" --ff-only
        done
    status:
      - test -d .modules
{{#if hbs.role}}
  update-readme-role:
    deps: [mod-ansible-autodoc]
    cmds:
      - task: update-readme

{{/if}}
{{#if hbs.ansible}}
  mod-ansible-autodoc:
    deps:
      - python-requirements
      - :software:jq
    env:
      ACTIONS_DESCRIPTION:
        sh: jq -r '.autodoc_actions_description' .variables.json
    cmds:
      - mod-ansible-autodoc --todo-title "### TODO" --actions-title "## Features" --actions-description "$ACTIONS_DESCRIPTION"
          --tags-title "### Tags" --variables-title "## Variables"
      - task: _mod-ansible-autodoc
      - mkdir -p .autodoc
      - mv ansible_actions.md ansible_tags.md ansible_todo.md ansible_variables.json ansible_variables.md ansible_variables_header.md .autodoc
    sources:
      - "tasks**/*.yml"
      - ".autodoc/*"
    preconditions:
      - sh: "type mod-ansible-autodoc &> /dev/null"
        msg:
          'The Python package `mod-ansible-autodoc` is missing. Ensure all the requirements are installed by running `task common:requirements`.
          Also, ensure `mod-ansible-autodoc` is included in the `requirements.txt` file.'

  _mod-ansible-autodoc:
    env:
      ROLE_VARIABLES:
        sh: jq -r '.role_variables' ansible_variables.json
      ROLE_VARIABLES_LENGTH:
        sh: jq -r '.role_variables | length' ansible_variables.json
      TMP:
        sh: mktemp
    cmds:
      - jq --arg vars "$ROLE_VARIABLES" '.role_variables = $vars' .variables.json > "$TMP"
      - mv "$TMP" .variables.json
      # yamllint disable rule:line-length
      - |
        if [[ "$ROLE_VARIABLES_LENGTH" == '0' ]]; then
          echo '## Variables\n\nThis role contains variables that you can customize. The variables you can customize are located in `defaults/main.yml`. By default, the variables use sensible defaults but you may want to customize the role depending on your use case. The variables, along with descriptions and examples, are listed in the chart below:\n\n\{{ ansible_variables }}\n\n' > ansible_variables_header.md
        else
          echo '' > ansible_variables_header.md
        fi
      # yamllint enable rule:line-length

  ansibler:
    deps:
      - python-requirements
    cmds:
      - task: ansibler-compatibility-chart
      - task: _ansibler
    preconditions:
      - sh: "type ansibler &> /dev/null"
        msg: "`ansibler` is not installed globally. Install all the requirements by running `task common:requirements`."
    status:
      - true

  _ansibler:
    deps: [{{#if hbs.role}}ansibler-populate-platforms, {{/if}}ansibler-role-dependencies]

  ansibler-compatibility-chart:
    cmds:
      - ansibler --generate-compatibility-chart
    sources:
      - .molecule-results/*.txt

{{#if hbs.role}}
  ansibler-populate-platforms:
    cmds:
      - ansibler --populate-platforms
    sources:
      - tasks/main.yml
      - .molecule-results/*.txt

{{/if}}
  ansibler-role-dependencies:
    cmds:
      - ansibler --role-dependencies
    sources:
      - requirements.yml

{{/if}}
  update-contributing:
    deps: [npm-prettier, npm-readme]
    vars:
      CONTRIB_TEMPLATE: .common/docs/blueprint-contributing.md
    cmds:
      - readme generate --config .variables.json --input "\{{.CONTRIB_TEMPLATE}}" --output CONTRIBUTING.md
      - task: _markdown-scrub
        vars:
          SCRUB_FILE: CONTRIBUTING.md
      - prettier --write CONTRIBUTING.md
    sources:
      - .variables.json
    preconditions:
      - sh: "test -f .common/docs/blueprint-contributing.md"
        msg: "The CONTRIBUTING.md template file is not present at `.common/docs/blueprint-contributing.md`"
      - sh: "test -f .variables.json"
        msg: "The .variables.json file is not present. Generate it by running `task common:update`."
      - sh: type readme &> /dev/null
        msg: "`@appnest/readme` is not installed globally. Install all the requirements by running `task common:requirements`."

  update-files:
    deps:
      - npm-prettier-package-json
      - :software:git
      - :software:jq
      - :software:rsync
    env:
{{#if hbs.ansible-molecule}}
      FIRSTLINE:
        sh: head -n 1 Dockerfile
{{/if}}
      PKG_BLUEPRINT:
        sh: jq -r '.blueprint' package.json
      PKG_DEPS:
        sh: jq -r '.dependencies' package.json
      PKG_DEV_DEPS:
        sh: jq -r '.devDependencies' package.json
      PKG_SCRIPTS:
        sh: jq -r '.scripts' package.json
      PKG_VERSION:
        sh: jq -r '.version' package.json
      TMP:
        sh: mktemp
    cmds:
      - task: _update-files
      - find .common/files-\{{.REPOSITORY_SUBTYPE}} -type f -name "*.handlebars" -delete
      - |
        if [[ '\{{.REPOSITORY_SUBTYPE}}' == 'ansible-molecule' ]] && ([[ "$FIRSTLINE" == *"debian"* ]] || [[ "$FIRSTLINE" == *"ubuntu"* ]]); then
          cp .common/initctl initctl
        fi
      - rsync -aPq ".common/files-\{{.REPOSITORY_SUBTYPE}}/" ./
      - chmod 755 .husky/pre-commit
      - task: update-sort
      # The following command merges upstream package.json dependencies and devDependencies and overwrites them with the upstream versions.
      # It allows the package.json in each project to include whatever dependencies it needs while at the same time it allows all the
      # common dependencies to be updated at the same time. It also ensures the version is persistent. It is entirely possible that this
      # might cause issues if a project relies on an outdated dependency or if the upstream dependencies are out of date.
      - jq --arg blueprint "$PKG_BLUEPRINT" --arg deps "$PKG_DEPS" --arg devDeps "$PKG_DEV_DEPS" --arg scripts "$PKG_SCRIPTS" --arg version "$PKG_VERSION"
        '.dependencies = (($deps | fromjson) * .dependencies) | .devDependencies = (($devDeps | fromjson) * .devDependencies)
        | .scripts = (($scripts | fromjson) * .scripts) | .blueprint = ($blueprint | fromjson) | .version = $version' package.json > "$TMP"
      - mv "$TMP" package.json
      - prettier-package-json --write
      - cd .common && git reset --hard HEAD && git clean -fd && cd ..
    sources:
      - package.json
      - .variables.json
    preconditions:
      - sh: "type rsync &> /dev/null"
        msg: "`rsync` is not installed!"
      - sh: "type prettier-package-json &> /dev/null"
        msg: "`prettier-package-json` is not installed globally. Install all the requirements by running `task common:requirements`."

{{#if hbs.role}}
  update-ansible-galaxy-id:
    vars:
      HAS_PROJECT_ID:
        sh: jq -e 'has("blueprint.ansible_galaxy_project_id")' package.json || true
    env:
      PROJECT_ID:
        sh: 'ansible-galaxy info "\{{.GALAXY_NAMESPACE}}.\{{.GALAXY_ROLE_NAME}}" | grep -E "id: [0-9]" | awk {"print $2"}'
      TMP:
        sh: mktemp
    cmds:
      - |
        if [ "$PROJECT_ID" ]; then
          jq --arg a "${PROJECT_ID}" '.blueprint.ansible_galaxy_project_id = $a' package.json > "$TMP"
          mv "$TMP" package.json
        fi
    status:
      - '[[ "\{{.HAS_PROJECT_ID}}" == "true" ]]'

{{/if}}
  _update-files:
    deps:
      - npm-hbs
    cmds:
      - |
        find ./.common/files-\{{.REPOSITORY_SUBTYPE}} -type f | while read FILE; do
          if [ "${FILE##*.}" == 'handlebars' ]; then
            FILE_BASENAME=$(basename $FILE)
            hbs --data .variables.json "$FILE" --stdout > "$(dirname $FILE)/${FILE_BASENAME%.*}"
          fi
        done
    sources:
      - .variables.json
    preconditions:
      - sh: "type hbs &> /dev/null"
        msg: "`hbs-cli` is not installed globally. Install all the requirements by running `task common:requirements`."

  update-latestos:
    deps:
      - python-requirements
      - :software:jq
    vars:
      TAG:
        sh: jq -r '.variables.latestos_tag' template.json
    cmds:
      - |
        if [ "${container:=}" != 'docker' ] && [[ '\{{.TAG}}' != 'macos' ]]; then
          latestos \{{.TAG}}
        fi
    status:
      - '[[ "\{{.TAG}}}" == "macos" ]] || [ "${container:=}" == "docker" ]'
    preconditions:
      - sh: test -f template.json
        msg: "The `template.json` file is missing from the root of this project."

  update-readme:
    deps: [npm-prettier, npm-readme]
    vars:
      README_TEMPLATE: blueprint-readme{{#if hbs.ansible}}-\{{.REPOSITORY_SUBTYPE}}{{/if}}.md
    cmds:
      - readme generate --config .variables.json --input ".common/docs/\{{.README_TEMPLATE}}"
      - task: _markdown-scrub
        vars:
          SCRUB_FILE: README.md
{{#if hbs.packer}}
      - task: update-readme-packer
{{/if}}
      - prettier --write README.md
    sources:
      - .autodoc/*
      - .variables.json
    preconditions:
      - sh: "test -f .common/docs/\{{.README_TEMPLATE}}"
        msg: "The README.md template file is not present at `.common/docs/\{{.README_TEMPLATE}}`."
      - sh: "test -f .variables.json"
        msg: "The `.variables.json` file is not present. Generate it by running `task common:update`."
      - sh: type readme &> /dev/null
        msg: "`@appnest/readme` is not installed globally. Install all the requirements by running `task common:requirements`."
      - sh: type prettier &> /dev/null
        msg: "`prettier` is not installed globally. Install all the requirements by running `task common:requirements`."

  update-readme-packer:
    cmds:
      - task: _update-readme-packer
        vars:
          TYPE: hyperv-iso
      - task: _update-readme-packer
        vars:
          TYPE: parallels-iso
      - task: _update-readme-packer
        vars:
          TYPE: qemu
      - task: _update-readme-packer
        vars:
          TYPE: virtualbox-iso
      - task: _update-readme-packer
        vars:
          TYPE: vmware-iso

  _update-readme-packer:
    cmds:
      - |
        if ! grep -q '"type": "\{{.TYPE}}"' template.json; then
          if [[ '{{OS}}' == 'darwin' ]]; then
            sed -i .bak '/SUPPORTED_OS_\{{.TYPE}}/d' README.md && rm README.md.bak
          elif [[ '{{OS}}' == 'linux' ]]; then
            sed -i '/SUPPORTED_OS_\{{.TYPE}}/d' README.md
          fi
        fi

  update-sort:
    cmds:
      - if [ -f paths.txt ]; then sort paths.txt -o paths.txt; fi
      - if [ -f requirements.txt ]; then sort requirements.txt -o requirements.txt; fi
    sources:
      - paths.txt
      - requirements.txt

  _markdown-scrub:
    vars:
      DIVIDER_SRC: <a href="\1" style="width:100%"><img style="width:100%" alt="-----------------------------------------------------"
        src="https://gitlab.com/megabyte-labs/assets/-/raw/master/png/aqua-divider.png" /></a>
      REGEX: .*https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/.*.png)][(]\(.*\)[)].*$
    cmds:
      - |
        if [[ '{{OS}}' == 'darwin' ]]; then
          sed -i .bak 's^\{{.REGEX}}^\{{.DIVIDER_SRC}}^g' \{{.SCRUB_FILE}} && rm \{{.SCRUB_FILE}}.bak
        else
          sed -i 's^\{{.REGEX}}^\{{.DIVIDER_SRC}}^g' \{{.SCRUB_FILE}}
        fi
