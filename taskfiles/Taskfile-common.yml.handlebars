---
version: '3'

tasks:
  clean:
    desc: Removes optional folders that are cached during various tasks
    summary: |
      $ Clean the project and remove all optional caches

      This task will remove all the unnecessary files that are downloaded, generated, and
      cached during various build steps. This task is used by the `task common:reset` task
      which will re-generate the project from scratch. Ideally, this task and the reset task
      should never be necessary. The `common:update` task should be used instead.
    cmds:
      - rm -rf .autodoc .task .variables.json .venv node_modules venv

  commit:
    deps: [nodejs-dependencies, python-requirements]
    desc: Lint staged files, report spelling errors, and open a _required_ commit dialoge
    summary: |
      $ Commit code

      This task will perform linting and auto-fixing on the files that have been staged in
      git (i.e. the files that were added with `git add --all`). It will then report possible
      spelling errors that you may choose to fix. Then, it opens a _required_ interactive commit
      questionnaire that will help you make better commits that are compatible with software
      that generates the CHANGELOG.md.

      It is very important that you use this task to commit rather than the conventional approach
      using `git commit -m`. However, if you really need to, you can add the flag `--no-verify`
      to your regular `git commit -m` command to bypass the pre-commit hook.
    cmds:
      - npm run lint-staged
      - task: spelling
      - npm run commit -- --no-verify

  markdown-link-check:
    deps: [nodejs-dependencies]
    desc: Scan markdown files for broken links
    summary: |
      $ Report any broken links in the files that end with .md

      This task uses the npm package called `markdown-link-check` to scan all the links
      and then report which ones are broken.

      For more information on `markdown-link-check`, see the following page:
      https://github.com/tcort/markdown-link-check
    cmds:
      - npm run misc:markdown-links

  prepare-release:
    deps: [nodejs-dependencies]
    desc: Ensure the project has upstream changes, lint, and then update the version
    summary: |
      $ Prepare a new release

      This task performs the following tasks in order:
      (1) Ensures the project is up-to-date with the latest upstream changes
      (2) Lints the project with all available linters
      (3) Updates the version of the project in the `package.json` file
      (4) Add the appropriate details to the CHANGELOG.md file
    cmds:
      - task: update
      - task: :lint:all
{{#if hbs.packer}}
      - task: :test:packer
{{/if}}
{{#if hbs.vagrant}}
      - task: :test:vagrant
{{/if}}
      - npm run version

  requirements:
    desc: Ensure all the dependencies are installed (Node.js, Python, etc.)
    summary: |
      $ Ensure dependencies are installed

      This task ensures that packages in various languages (Node.js, Python, etc.) are installed.
      At the very minimum, it will install the Node.js requirements by running `npm install` and
      then install the Python requirements by running `pip3 install -r requirements` after
      initiating a `virtualenv`. In some types of projects, additional types of requirements are
      installed (e.g. Ansible projects also install Ansible Galaxy requirements).
    deps: [nodejs-dependencies, nodejs-global-dependencies, python-requirements{{#if hbs.ansible}}, galaxy-requirements{{/if}}]
{{#if hbs.ansible}}

  galaxy-requirements:
    deps: [python-requirements]
    cmds:
      - |
        if [ "${container:=}" != 'docker' ]; then
          ansible-galaxy install -r requirements.yml --ignore-errors
        fi
    sources:
      - requirements.yml
    preconditions:
      - sh: "test -f requirements.yml"
        msg: "The requirements.yml file is missing! It should be present even if it is empty (which should almost never be the case)."
{{/if}}

  reset:
    desc: Resets the project by removing all caches and updating the project
    summary: |
      $ Reset the project and then update it

      This task is intended to be used when the `common:update` task is having trouble
      or when breaking changes are made to the build tools. Use this task if you are
      having trouble with other tasks that are dependent on stale caches. Unlike
      `task common:hard-reset`, this will not remove uncommitted work (assuming your
      work does not reside in folders ignored by the `.gitignore` file).
    cmds:
      - task: clean
      - task: update

  reset-force:
    deps:
      - software:git
    desc: "Aggressively reset the project (WARNING: This will wipe uncommitted work)"
    summary: |
      $ Aggressively reset the project

      If using `task common:reset` does not fix your issues, you can run this task
      to completely wipe out uncommitted work, clear all the caches, and sync
      with the master branch of both this project and its upstream repositories.
    cmds:
      - git reset --hard HEAD
      - git clean -fxd :/
      - git checkout master
      - git pull origin master
      - bash .start.sh

  nodejs-dependencies:
    deps:
      - :software:node
    cmds:
      - if [ "${container:=}" != 'docker' ]; then npm install; fi
    sources:
      - package.json
      - package-lock.json
    status:
      - test -d node_modules
    preconditions:
      - sh: "test -f package.json"
        msg: "The package.json file appears to be missing!"

  nodejs-global-dependencies:
    deps: [npm-hbs, npm-prettier, npm-prettier-package-json, npm-readme]
    status:
      - '[[ "${container:=}" == "docker" ]]'

  npm-hbs:
    deps:
      - :software:node
    cmds:
      - if [ "${container:=}" != 'docker' ]; then npm install -g hbs-cli; fi
    status:
      - type hbs &> /dev/null

  npm-prettier:
    deps:
      - :software:node
    cmds:
      - |
        if [ "${container:=}" != 'docker' ]; then
          npm install -g prettier prettier-plugin-sh @megabytelabs/prettier-config{{#if hbs.ansible}} @megabytelabs/prettier-config-ansible{{/if}}
        fi
    status:
      - type prettier &> /dev/null

  npm-prettier-package-json:
    deps:
      - :software:node
    cmds:
      - if [ "${container:=}" != 'docker' ]; then npm install -g prettier-package-json; fi
    status:
      - type prettier-package-json &> /dev/null

  npm-readme:
    deps:
      - :software:node
    cmds:
      - if [ "${container:=}" != 'docker' ]; then npm install -g @appnest/readme; fi
    status:
      - type readme &> /dev/null

  python-requirements:
    deps:
      - :software:python
    cmds:
      - task: python-requirements-venv
      - task: python-requirements-venv-activate
      - task: python-requirements-pip
    status:
      - '[[ "${container:=}" == "docker" ]]'

  python-requirements-venv:
    cmds:
      - task: python-virtualenv
      - rm -rf .venv
      - virtualenv .venv
    status:
      - test -f .venv/bin/activate

  python-requirements-venv-activate:
    cmds:
      - . .venv/bin/activate
    status:
      - '[[ "$PATH" =~ "$PWD/.venv/bin" ]]'

  python-requirements-pip:
    cmds:
      - pip3 install -r requirements.txt
    sources:
      - requirements.txt
    preconditions:
      - sh: "test -f requirements.txt"
        msg: "The requirements.txt file is missing!"

  python-virtualenv:
    cmds:
      - pip3 install virtualenv
    status:
      - type virtualenv &> /dev/null

  shell:
    deps:
      - :software:docker
    desc: Start a terminal session using Docker with any Linux operating system
    summary: |
      $ Start a Docker terminal session

      Use Docker to run commands on nearly any operating system. The operating
      systems are all stock distros with systemd added.

      Example opening an interactive prompt:
      > task shell

      Example of directly shelling into a container:
      > task shell -- ubuntu-21.04

      Available operating systems:
        * archlinux   * debian-9     * fedora-34      * ubuntu-21.04
        * centos-7    * debian-10    * ubuntu-18.04
        * centos-8    * fedora-33    * ubuntu-20.04
    vars:
      WORKDIR:
        sh: basename $PWD
    cmds:
      - if [ ! -z "\{{.CLI_ARGS}}" ]; then docker run --cap-drop=ALL -it -v "$PWD:/\{{.WORKDIR}}" -w /\{{.WORKDIR}}
          --rm megabytelabs/ansible-molecule-\{{.CLI_ARGS}}:latest /bin/bash; fi
      - task: shell-prompt
    preconditions:
      - sh: "type docker &> /dev/null"
        msg: "Docker is not installed! Install it by running `task software:docker`."

    shell-prompt:
      deps:
        - :software:node
      env:
        OPERATING_SYSTEM:
          sh: node .common/scripts/prompts/shell.js
      cmds:
        - if [ ! -z "$OPERATING_SYSTEM" ]; then docker run --cap-drop=ALL -it -v "$PWD:/\{{.WORKDIR}}" -w /\{{.WORKDIR}}
            --rm "megabytelabs/ansible-molecule-${OPERATING_SYSTEM}:latest" /bin/bash; fi
      preconditions:
        - sh: "type node &> /dev/null"
          msg: "Node.js is not installed! Install it by running `task software:node`."
      status:
        - '[[ -z "\{{.CLI_ARGS}}" ]]'

  spelling:
    deps:
      - :software:git
      - :software:node
    desc: Checks for spelling errors in staged files
    summary: |
      $ Check for spelling errors in staged files

      Use cspell to check for possible spelling errors using the configuration stored in `.common/.cspell.json`.

      This task is utilized by the pre-commit hook. For more information about cspell, see:
      https://www.npmjs.com/package/cspell

      Although this task only analyzes staged files, you can manually run cspell, for example, on all JavaScript
      files by running:
      > npx cspell '**/*.js'
    env:
      STAGED_FILES:
        sh: git diff --cached --name-only
    cmds:
      - npx cspell --no-summary --no-progress --show-context --no-must-find-files --config .common/.cspell.json "$STAGED_FILES" || true
    preconditions:
      - sh: "git diff --cached --name-only"
        msg: "Cannot perform a spell check because there are no staged files"

  update:
    desc: Refresh the project with the latest upstream code and ensure blueprint data has propagated
    cmds:
      - task: update-common
      - task: update-start-sh
      - task: update-taskfile
      - task: requirements
      - task: update-variables
      - task: update-all
      - bash .common/scripts/log-bash.sh success "Successfully updated the project with the latest upstream changes"

  update-common:
    deps:
      - :software:git
    cmds:
      - cd .common
      - git reset --hard HEAD
      - git pull origin master --ff-only
      - cd ..
    preconditions:
      - sh: "type git &> /dev/null"
        msg: "git is not installed! You can install it by running `task software:git`."

  update-start-sh:
    cmds:
      - cp .common/.start.sh .start.sh
    sources:
      - .common/start.sh

  update-taskfile:
    cmds:
      - cp .common/files-\{{.REPOSITORY_SUBTYPE}}/Taskfile.yml Taskfile.yml
    sources:
      - .common/files-\{{.REPOSITORY_SUBTYPE}}/Taskfile.yml

  update-variables:
    deps:
      - :software:jq
      - :software:yq
{{#if hbs.ansible}}
      - ansibler
{{/if}}
    env:
      BLUEPRINT_DATA:
        sh: jq -r '.blueprint' package.json
{{#if hbs.role}}
      DESCRIPTION:
        sh: yq e '.galaxy_info.description' meta/main.yml
      DESCRIPTION_FIRST_LETTER:
        sh: echo ${DESCRIPTION:0:1} | tr '[A-Z]' '[a-z]'
      GALAXY_INFO:
        sh: yq e -j '.galaxy_info' meta/main.yml
{{/if}}
      TMP_JQ:
        sh: mktemp
      TMP_VARS:
        sh: mktemp
    vars:
      COMMON_JSON: ".common/common.\{{.REPOSITORY_SUBTYPE}}.json"
    cmds:
      - jq -S --arg blueprint "$BLUEPRINT_DATA" '. = . * ($blueprint | fromjson)' ".common/variables.\{{.REPOSITORY_SUBTYPE}}.json" > "$TMP_VARS"
      - mv "$TMP_VARS" .variables.json
{{#if hbs.role}}
      - LOWERCASE_DESCRIPTION="${DESCRIPTION_FIRST_LETTER}${DESCRIPTION:1}"
      - SUBHEADER_DESCRIPTION="An Ansible role that ${LOWERCASE_DESCRIPTION}"
      - ALT_DESCRIPTION="This repository is the home of an [Ansible](https://www.ansible.com/) role that ${LOWERCASE_DESCRIPTION}."
      - jq -S --arg subheader "$SUBHEADER_DESCRIPTION" --arg alt "$ALT_DESCRIPTION" --arg galaxyinfo "$GALAXY_INFO"
          '.subheader_description = $subheader | .alternative_description = $alt | .galaxy_info = ($galaxyinfo | fromjson)' .variables.json > "$TMP_JQ"
      - mv "$TMP_JQ" .variables.json
{{/if}}
    sources:
      - ".common/variables.\{{.REPOSITORY_SUBTYPE}}.json"
      - package.json
{{#if hbs.role}}
      -  meta/main.yml
{{/if}}
    preconditions:
      - sh: "type jq &> /dev/null"
        msg: "jq is not installed! You can install it by running `task software:jq`."
      - sh: "type yq &> /dev/null"
        msg: "yq is not installed! You can install it by running `task software:yq`."
{{#if hbs.role}}
      - sh: "test -f meta/main.yml"
        msg: "The `meta/main.yml` file is missing. A properly populated `meta/main.yml` is required. You can find an
          example of one at https://github.com/ProfessorManhattan/ansible-snapd."
{{/if}}

  update-all:
    deps: [update-contributing, update-readme{{#if hbs.role}}-role{{/if}}, update-files]

  update-modules:
    deps:
      - :software:git
    desc: Ensure all submodules in the `.modules/` folder are updated
    summary: |
      $ Ensure all submodules in `.modules/` are updated

      Some of our projects include submodules. These submodules are generally
      stored in the `.modules/` folder in the root of the project. Some projects
      might symlink files to one of the submodules stored in the `.modules/` folder.
      If you are ok with the risk, you can use this task to update all the submodules
      to the latest on the remote's master branch.
    cmds:
      - |
        for SUBMODULE_PATH in .modules/*; do
          cd $SUBMODULE_PATH
          DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
          git reset --hard HEAD
          git checkout "$DEFAULT_BRANCH"
          git pull origin "$DEFAULT_BRANCH" --ff-only
        done
    status:
      - test -d .modules
{{#if hbs.role}}

  update-readme-role:
    deps: [mod-ansible-autodoc]
    cmds:
      - task: update-readme
{{/if}}
{{#if hbs.ansible}}

  mod-ansible-autodoc:
    deps:
      - python-requirements
      - :software:jq
    env:
      ACTIONS_DESCRIPTION:
        sh: jq -r '.autodoc_actions_description' .variables.json
    cmds:
      - mod-ansible-autodoc --todo-title "### TODO" --actions-title "## Features" --actions-description "$ACTIONS_DESCRIPTION"
          --tags-title "### Tags" --variables-title "## Variables"
      - task: _mod-ansible-autodoc
      - mkdir -p .autodoc
      - mv ansible_actions.md ansible_tags.md ansible_todo.md ansible_variables.json ansible_variables.md .autodoc
    sources:
      - "tasks**/*.yml"
    preconditions:
      - sh: "type mod-ansible-autodoc &> /dev/null"
        msg:
          'The Python package `mod-ansible-autodoc` is missing. Ensure all the requirements are installed by running `task common:requirements`.
          Also, ensure `mod-ansible-autodoc` is included in the `requirements.txt` file.'

  _mod-ansible-autodoc:
    env:
      ROLE_VARIABLES:
        sh: jq -r '.role_variables' ansible_variables.json
      TMP:
        sh: mktemp
    cmds:
      - jq --arg vars "$ROLE_VARIABLES" '.role_variables = $vars' .variables.json > "$TMP"
      - mv "$TMP" .variables.json

  ansibler:
    deps:
      - python-requirements
    cmds:
      - task: ansibler-compatibility-chart
      - task: _ansibler
    preconditions:
      - sh: "type ansibler &> /dev/null"
        msg: "`ansibler` is not installed globally. Install all the requirements by running `task common:requirements`."
    status:
      - true

  _ansibler:
    deps: [{{#if hbs.role}}ansibler-populate-platforms, {{/if}}ansibler-role-dependencies]

  ansibler-compatibility-chart:
    cmds:
      - ansibler --generate-compatibility-chart
    sources:
      - .molecule-results/*.txt

{{#if hbs.role}}
  ansibler-populate-platforms:
    cmds:
      - ansibler --populate-platforms
    sources:
      - tasks/main.yml
      - .molecule-results/*.txt
{{/if}}

  ansibler-role-dependencies:
    cmds:
      - ansibler --role-dependencies
    sources:
      - requirements.yml
{{/if}}

  update-contributing:
    deps: [npm-prettier, npm-readme]
    vars:
      CONTRIB_TEMPLATE: .common/docs/blueprint-contributing.md
    cmds:
      - readme generate --config .variables.json --input "\{{.CONTRIB_TEMPLATE}}" --output CONTRIBUTING.md
      - task: _markdown-scrub
        vars:
          SCRUB_FILE: CONTRIBUTING.md
      - prettier --write CONTRIBUTING.md
    sources:
      - .variables.json
    preconditions:
      - sh: "test -f .common/docs/blueprint-contributing.md"
        msg: "The CONTRIBUTING.md template file is not present at `.common/docs/blueprint-contributing.md`"
      - sh: "test -f .variables.json"
        msg: "The .variables.json file is not present. Generate it by running `task common:update`."
      - sh: type readme &> /dev/null
        msg: "`@appnest/readme` is not installed globally. Install all the requirements by running `task common:requirements`."

  update-files:
    deps:
      - npm-prettier-package-json
      - :software:git
      - :software:jq
      - :software:rsync
    env:
      PKG_BLUEPRINT:
        sh: jq -r '.blueprint' package.json
      PKG_DEPS:
        sh: jq -r '.dependencies' package.json
      PKG_DEV_DEPS:
        sh: jq -r '.devDependencies' package.json
      PKG_SCRIPTS:
        sh: jq -r '.scripts' package.json
      PKG_VERSION:
        sh: jq -r '.version' package.json
      TMP:
        sh: mktemp
    cmds:
      - task: _update-files
      - find .common/files-\{{.REPOSITORY_SUBTYPE}} -type f -name "*.handlebars" -delete
      - rsync -aPq ".common/files-\{{.REPOSITORY_SUBTYPE}}/" ./
      # The following command merges upstream package.json dependencies and devDependencies and overwrites them with the upstream versions.
      # It allows the package.json in each project to include whatever dependencies it needs while at the same time it allows all the
      # common dependencies to be updated at the same time. It also ensures the version is persistent. It is entirely possible that this
      # might cause issues if a project relies on an outdated dependency or if the upstream dependencies are out of date.
      - jq --arg blueprint "$PKG_BLUEPRINT" --arg deps "$PKG_DEPS" --arg devDeps "$PKG_DEV_DEPS" --arg scripts "$PKG_SCRIPTS" --arg version "$PKG_VERSION"
        '.dependencies = (($deps | fromjson) * .dependencies) | .devDependencies = (($devDeps | fromjson) * .devDependencies)
        | .scripts = (($scripts | fromjson) * .scripts) | .blueprint = ($blueprint | fromjson) | .version = $version' package.json > "$TMP"
      - mv "$TMP" package.json
      - prettier-package-json --write
      - cd .common && git reset --hard HEAD && git clean -fd && cd ..
    sources:
      - package.json
    preconditions:
      - sh: "type rsync &> /dev/null"
        msg: "`rsync` is not installed!"
      - sh: "type prettier-package-json &> /dev/null"
        msg: "`prettier-package-json` is not installed globally. Install all the requirements by running `task common:requirements`."

  _update-files:
    deps:
      - npm-hbs
    cmds:
      - |
        find ./.common/files-\{{.REPOSITORY_SUBTYPE}} -type f | while read FILE; do
          if [ "${FILE##*.}" == 'handlebars' ]; then
            FILE_BASENAME=$(basename $FILE)
            hbs --data .variables.json "$FILE" --stdout > "$(dirname $FILE)/${FILE_BASENAME%.*}"
          fi
        done
    sources:
      - .variables.json
    preconditions:
      - sh: "type hbs &> /dev/null"
        msg: "`hbs-cli` is not installed globally. Install all the requirements by running `task common:requirements`."

  update-readme:
    deps: [npm-prettier, npm-readme]
    vars:
      README_TEMPLATE: blueprint-readme{{#if hbs.ansible}}-\{{.REPOSITORY_SUBTYPE}}{{/if}}.md
    cmds:
      - readme generate --config .variables.json --input ".common/docs/\{{.README_TEMPLATE}}"
      - task: _markdown-scrub
        vars:
          SCRUB_FILE: README.md
      - prettier --write README.md
    sources:
      - .autodoc/*
      - .variables.json
    preconditions:
      - sh: "test -f .common/docs/\{{.README_TEMPLATE}}"
        msg: "The README.md template file is not present at `.common/docs/\{{.README_TEMPLATE}}`."
      - sh: "test -f .variables.json"
        msg: "The `.variables.json` file is not present. Generate it by running `task common:update`."
      - sh: type readme &> /dev/null
        msg: "`@appnest/readme` is not installed globally. Install all the requirements by running `task common:requirements`."
      - sh: type prettier &> /dev/null
        msg: "`prettier` is not installed globally. Install all the requirements by running `task common:requirements`."

  _markdown-scrub:
    vars:
      DIVIDER_SRC: <a href="\1" style="width:100%"><img style="width:100%" alt="-----------------------------------------------------"
        src="https://gitlab.com/megabyte-labs/assets/-/raw/master/png/aqua-divider.png" /></a>
      REGEX: .*https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/.*.png)][(]\(.*\)[)].*$
    cmds:
      - |
        if [[ '{{OS}}' == 'darwin' ]]; then
          sed -i .bak 's^\{{.REGEX}}^\{{.DIVIDER_SRC}}^g' \{{.SCRUB_FILE}} && rm \{{.SCRUB_FILE}}.bak
        else
          sed -i 's^\{{.REGEX}}^\{{.DIVIDER_SRC}}^g' \{{.SCRUB_FILE}}
        fi
