---
version: '3'

tasks:
  ansibler-compatibility-chart:
    cmds:
      - ansibler --generate-compatibility-chart
    sources:
      - .molecule-results/*.txt

{{#if hbs.role}}
  ansibler-populate-platforms:
    cmds:
      - ansibler --populate-platforms
    sources:
      - tasks/main.yml
      - .molecule-results/*.txt

{{/if}}
  ansibler-role-dependencies:
    cmds:
      - ansibler --role-dependencies
    sources:
      - requirements.yml

  ansibler-tasks:
    deps:
{{#if hbs.role}}
      - ansibler-populate-platforms
{{/if}}
      - ansibler-role-dependencies

  ansibler:
    deps:
      - :common:python-requirements
    cmds:
      - task: ansibler-compatibility-chart
      - task: ansibler-tasks
    preconditions:
      - sh: "type ansibler &> /dev/null"
        msg: "`ansibler` is not installed globally. Install all the requirements by running `task common:requirements`."
    status:
      - true

{{#if hbs.playbook}}
  environment-prompt:
    deps:
      - :common:nodejs-dependencies
    env:
      ENVIRONMENT:
        sh: node .common/scripts/prompts/environment.js
    cmds:
        - |
          if [ ! -z "$ENVIRONMENT" ]; then
            for ITEM in "environments/$ENVIRONMENT/*"; do
              if [ -d "$ITEM" ] || [ -f "$ITEM" ]; then
                true info "Skipping environments/$ENVIRONMENT/$ITEM because it already exists as a file/folder in the root of the project."
              else
                rm -f $ITEM
                ln -s "./environments/$ENVIRONMENT/$ITEM" "$ITEM"
              fi
            done
          fi
    preconditions:
      - sh: "test -d node_modules"
        msg: "This task has dependencies in the `node_modules` folder which is missing. Install them by running `task common:nodejs-dependencies`."
    status:
      - '[[ -z "\{{.CLI_ARGS}}" ]]'

  environment:
    desc: Prompts for which environment to use and then symlinks to it
    summary: |
      $ Switch environments using an interactive dialogue

      Ansible does not really provide any great ways to switch between environments (or sets of
      host_vars, group_vars etc.). If you place all the files and folders you wish to constitute
      as an environment inside a folder named as the name of the environment then you can use
      this task to handle the symlinking and switching between environments.

      You can directly switch enironments to `environments/prod/` by running:
      > task ansible:environment -- prod
    cmds:
      - |
        if [ ! -z "\{{.CLI_ARGS}}" ]; then
          for ITEM in environments/\{{.CLI_ARGS}}/*; do
            if [ -d "$ITEM" ] || [ -f "$ITEM" ]; then
              true info "Skipping environments/\{{.CLI_ARGS}}/$ITEM because it already exists as a file/folder in the root of the project."
            else
              rm -f $ITEM
              ln -s "./environments/\{{.CLI_ARGS}}/$ITEM" "$ITEM"
            fi
          done
        fi
      - task: environment-prompt

  find-missing-files:
    desc: Find roles that are missing files
    summary: |
      $ Find roles that are missing any given file

      This task scans through all the folders in the roles/ directory and checks
      for the presence of a file that you pass in through the CLI.

      Example usage:
      > task find-missing-files -- logo.png

      The example above will look through all the folders two levels deep (e.g. ./roles/tools/nmap,
      ./roles/system/snapd)in the roles folder and display any roles that are missing the file.
    cmds:
      - find ./roles -mindepth 2 -maxdepth 2 -type d '!' -exec test -e "{}/\{{.CLI_ARGS}}" ';' -print
    preconditions:
      - sh: "test -d roles"
        msg: "The roles folder is missing. Is the project set up right?"

{{/if}}
{{#if hbs.role}}
  mod-ansible-autodoc-variables:
    env:
      ROLE_VARIABLES:
        sh: jq -r '.role_variables' ansible_variables.json
      TMP:
        sh: mktemp
    cmds:
      - jq --arg vars "$ROLE_VARIABLES" '.role_variables = $vars' .variables.json > "$TMP"
      - mv "$TMP" .variables.json

  mod-ansible-autodoc:
    deps:
      - :common:python-requirements
      - :software:jq
    env:
      ACTIONS_DESCRIPTION:
        sh: jq -r '.autodoc_actions_description' .variables.json
      TAGS_DESCRIPTION:
        sh: jq -r '.autodoc_tags_description' .variables.json
      TODO_DESCRIPTION:
        sh: jq -r '.autodoc_todo_description' .variables.json
      VARIABLES_DESCRIPTION:
        sh: jq -r '.autodoc_variables_description' .variables.json
    cmds:
      - mod-ansible-autodoc --actions-title "## Features" --actions-description "$ACTIONS_DESCRIPTION"
          --tags-title "### Tags" --tags-description "$TAGS_DESCRIPTION" --todo-title "### TODO"
          --todo-description "$TODO_DESCRIPTION" --variables-title "## Variables" --variables-description
          "$VARIABLES_DESCRIPTION"
      - task: mod-ansible-autodoc-variables
      - mkdir -p .autodoc
      - mv ansible_actions.md ansible_tags.md ansible_todo.md ansible_variables.json ansible_variables.md .autodoc
    sources:
      - "tasks**/*.yml"
      - ".autodoc/*"
    preconditions:
      - sh: "type mod-ansible-autodoc &> /dev/null"
        msg: "The Python package `mod-ansible-autodoc` is missing. Ensure all the requirements are installed
          by running `task common:requirements`. Also, ensure `mod-ansible-autodoc` is included in the `requirements.txt`
          file."

  populate-collection:
    deps:
      - :software:yq
    env:
      COLLECTIONS:
        sh: yq eval '.collections' requirements.yml
      REFERENCES:
        sh: grep -Ril "\{{.KEY}}" ./tasks || true
    cmds:
      - |
        if [[ ! "$COLLECTIONS" =~ "\{{.KEY}}" ]] && [ "$REFERENCES" ]; then
          yq eval -i -P '.collections = .collections + \{{.VAL}}' requirements.yml
        fi
    status:
      - '[[ "$COLLECTIONS" =~ "\{{.KEY}}" ]] || [ ! "$REFERENCES" ]'

  populate-dependencies:
    desc: Attempt to automatically populate meta/main.yml and requirements.yml
    summary: |
      $ Automatically populate meta/main.yml and requirements.yml

      A role can sometimes have dependencies that need to be installed prior to being run (e.g. most
      roles in Ansible >2.9 need the `community.general` collection installed). Roles also sometimes
      need other roles to run before they are run (e.g. a task that installs a Node.js package needs
      the Node.js installer to run first). This task will scan for common dependencies by doing a text
      search for a handful of common strings. It will then attempt to automatically populate
      `meta/main.yml` and the `requirements.yml`.

      Items it attempts to auto-populate for:
        * chocolatey.chocolatey        * community.general.gem
        * community.general            * community.general.npm
        * community.general.homebrew   * community.general.snap
    cmds:
      - task: populate-collection
        vars:
          KEY: chocolatey.chocolatey
          VAL: '{"name": "chocolatey.chocolatey", "source": "https://galaxy.ansible.com"}'
      - task: populate-collection
        vars:
          KEY: community.general
          VAL: '{"name": "community.general", "source": "https://galaxy.ansible.com"}'
      - task: populate-dependency
        vars:
          KEY: community.general.homebrew
          ROLE: professormanhattan.homebrew
          VAL: '{"role": "professormanhattan.homebrew", "when": "ansible_os_family == \"Darwin\""}'
      - task: populate-dependency
        vars:
          KEY: community.general.npm
          ROLE: professormanhattan.nodejs
          VAL: '{"role": "professormanhattan.nodejs"}'
      - task: populate-dependency
        vars:
          KEY: community.general.gem
          ROLE: professormanhattan.ruby
          VAL: '{"role": "professormanhattan.ruby"}'
      - task: populate-dependency
        vars:
          KEY: community.general.snap
          ROLE: professormanhattan.snapd
          VAL: '{"role": "professormanhattan.snapd", "when": "ansible_system == \"Linux\""}'
      - task: sync-requirements
    sources:
      - meta/main.yml
      - requirements.yml
      - tasks/**/*.yml

  populate-dependency:
    deps:
      - :software:yq
    env:
      DEPENDENCIES:
        sh: yq eval '.dependencies' meta/main.yml
      REFERENCES:
        sh: grep -Ril "\{{.KEY}}" ./tasks || true
    cmds:
      - |
        if [[ ! "$DEPENDENCIES" =~ "\{{.ROLE}}" ]] && [ "$REFERENCES" ]; then
          yq eval -i -P '.dependencies = .dependencies + \{{.VAL}}' meta/main.yml
        fi
    status:
      - '[[ "$DEPENDENCIES" =~ "\{{.ROLE}}" ]] || [ ! "$REFERENCES" ]'

{{/if}}
{{#if hbs.playbook}}
  symlink:
    desc: Symlink all the roles in the roles/ folder to ~/.ansible/roles
    summary: |
      $ Symlink each role to ~/.ansible/roles/\{{.GALAXY_NAMESPACE}}.\role_name

      In the playbook, roles are sometimes referred to by their folder name and in other cases
      they are referred to with their namespace prepended (e.g. \{{.GALAXY_NAMESPACE}}.role_name).
      This can cause issues so, in order for everything to work, each folder needs to be symlinked
      to ~/.ansible/roles with the namespace prepended.
    cmds:
      - |
        find ./roles -mindepth 2 -maxdepth 2 -type d -print0 | while read -d $'\0' ROLE_PATH; do;
          PATH_BASENAME=$(basename "$ROLE_PATH");
          if [ ! -d "~/.ansible/roles/\{{.GALAXY_NAMESPACE}}.$PATH_BASENAME" ]; then
            ln -sf "$PWD/$ROLE_PATH" "~/.ansible/roles/\{{.GALAXY_NAMESPACE}}.$PATH_BASENAME"
          fi
        done
    preconditions:
      - sh: "test -d roles"
        msg: "The roles folder is missing. Is the project set up right?"
{{/if}}
{{#if hbs.role}}
  symlink:
    desc: Symlink the current role to ~/.ansible/roles/\{{.GALAXY_NAMESPACE}}.\{{.GALAXY_ROLE_NAME}}
    summary: |
      $ Symlink this role to ~/.ansible/roles/\{{.GALAXY_NAMESPACE}}.\{{.GALAXY_ROLE_NAME}}

      Roles are sometimes referred to by their folder name (which ideally is also the role_name in
      the meta/main.yml file) and they are sometimes referred to by their Ansible Galaxy name which
      has the namespace prepended (e.g. \{{.GALAXY_NAMESPACE}}.role_name). In order to make sure Ansible
      can find the role in both cases, a symlink in ~/.ansible/roles that points to the folder needs
      to be created.
    vars:
      SYMLINK:
        sh: readlink "$HOME/.ansible/roles/professormanhattan.androidstudio"
    cmds:
      - mkdir -p "$HOME/.ansible/roles"
      - rm -f "$HOME/.ansible/roles/\{{.GALAXY_NAMESPACE}}.\{{.GALAXY_ROLE_NAME}}"
      - ln -s "$PWD" "~/.ansible/roles/\{{.GALAXY_NAMESPACE}}.\{{.GALAXY_ROLE_NAME}}"
    status:
      - test -d "$HOME/.ansible/roles/professormanhattan.androidstudio"
      - '[ "\{{.SYMLINK}}" == "$PWD" ]'

  sync-requirements:
    deps:
      - :software:jq
      - :software:yq
    env:
      ROLES:
        sh: yq eval '.roles' requirements.yml
      TMP:
        sh: mktemp
    cmds:
      - yq eval -j '.dependencies' meta/main.yml > "$TMP"
      - |
        jq -rc '.[] .role' "$TMP" | while read ROLE_NAME; do
          if [[ ! "$ROLES" =~ "$ROLE_NAME" ]]; then
            ROLE_NAME="$ROLE_NAME" yq eval -i -P '.roles = .roles + {"name": env(ROLE_NAME)}' requirements.yml
          fi
        done

  update-galaxy-id:
    vars:
      HAS_PROJECT_ID:
        sh: jq -e 'has("blueprint.ansible_galaxy_project_id")' package.json || true
    env:
      PROJECT_ID:
        sh: '(ansible-galaxy info "\{{.GALAXY_NAMESPACE}}.\{{.GALAXY_ROLE_NAME}}" | grep -E "id: [0-9]" | awk {"print $2"}) 2> /dev/null || true'
      TMP:
        sh: mktemp
    cmds:
      - |
        if [ "$PROJECT_ID" ]; then
          jq --arg a "${PROJECT_ID}" '.blueprint.ansible_galaxy_project_id = $a' package.json > "$TMP"
          mv "$TMP" package.json
        fi
    status:
      - '[[ "\{{.HAS_PROJECT_ID}}" == "true" ]]'

  update-variables:
    deps:
      - :software:jq
      - :software:yq
    env:
      DESCRIPTION:
        sh: yq e '.galaxy_info.description' meta/main.yml
      DESCRIPTION_FIRST_LETTER:
        sh: echo ${DESCRIPTION:0:1} | tr '[A-Z]' '[a-z]'
      DESCRIPTION_LOWERCASE:
        sh: echo "${DESCRIPTION_FIRST_LETTER}${DESCRIPTION:1}"
      DESCRIPTION_SUBHEADER:
        sh: echo "An Ansible role that ${LOWERCASE_DESCRIPTION}"
      DESCRIPTION_ALT:
        sh: echo "This repository is the home of an [Ansible](https://www.ansible.com/) role that ${LOWERCASE_DESCRIPTION}."
      GALAXY_INFO:
        sh: yq e -j '.galaxy_info' meta/main.yml
      TMP:
        sh: mktemp
    cmds:
      - jq -S --arg subheader "$DESCRIPTION_SUBHEADER" --arg alt "$DESCRIPTION_ALT" --arg galaxyinfo "$GALAXY_INFO"
          '.subheader_description = $subheader | .alternative_description = $alt | .galaxy_info = ($galaxyinfo | fromjson)' .variables.json > "$TMP"
      - mv "$TMP" .variables.json
    preconditions:
      - sh: "type jq &> /dev/null"
        msg: "jq is not installed! You can install it by running `task software:jq`."
      - sh: "type yq &> /dev/null"
        msg: "yq is not installed! You can install it by running `task software:yq`."
      - sh: "test -f meta/main.yml"
        msg: "The `meta/main.yml` file is missing. A properly populated `meta/main.yml` is required. You can find an
          example of one at https://github.com/ProfessorManhattan/ansible-snapd."
      - sh: test -f .variables.json
        msg: "The `.variables.json` file is missing!"
    sources:
      - ".common/variables.\{{.REPOSITORY_SUBTYPE}}.json"
      - meta/main.yml
      - package.json

{{/if}}
