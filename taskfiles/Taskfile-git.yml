---
version: '3'

vars:
  GITHUB_ISSUES: true
  GITHUB_WIKI: false
  GITLAB_WIKI: false

env:
  CLICOLOR:
    sh: if [[ "${container:=}" == 'docker' ]]; then echo "0"; else echo "1"; fi

tasks:
  convert:folder:submodule:
    deps:
      - github:update
      - gitlab:update
    vars:
      BASENAME:
        sh: basename "$PWD"
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json
    cmds:
      - git init
      - git remote add origin "{{.GITLAB_REPO}}"
      - git add --all
      - git commit -m "refactor(convert-dir-to-submodule) Adding folder/project to its own git repository."
      - git push origin master
      - |
        cd ..
        rm -rf {{.BASENAME}}
        git add {{.BASENAME}}
        git commit -m "refactor(convert-dir-to-submodule) Removing folder which will now be a submodule."
        git submodule add -b master "{{.GITLAB_REPO}}" {{.BASENAME}}
        git add {{.BASENAME}}
        git commit -m "refactor(convert-dir-to-submodule) Adding new submodule which was previously a directory."
        git push -u origin HEAD
      - true success 'Converted the `{{.BASENAME}}` directory to a submodule'
    preconditions:
      - sh: '[[ ! $(git rev-parse --git-dir) =~ ".git/modules" ]]'
        msg: Cannot convert the directory to a submodule - the directory already appears to be a submodule.

  github:create:
    deps:
      - :install:software:gh
      - :install:software:jq
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      HOMEPAGE:
        sh: jq -r '.homepage' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo '--private'; else echo '--public'; fi
    env:
      TMP:
        sh: mktemp
    run: once
    cmds:
      - ignore_error: true
        cmd: >
          if [ ! -z "$GITHUB_TOKEN" ]; then
            if [[ ! "$(gh repo view {{.GITHUB_ORG}}/{{.GITHUB_SLUG}})" ]]; then
              gh repo create "{{.GITHUB_SLUG}}" --enable-wiki={{.GITHUB_WIKI}} -y --description "{{.DESCRIPTION}}" --homepage "{{.HOMEPAGE}}"
                {{.PROJECT_TYPE}}
            fi
          else
            true warn 'The `GITHUB_TOKEN` environment variable is not set so the GitLab repository cannot be updated via the API.'
          fi
    status:
      - '[[ "$(gh repo view {{.GITHUB_ORG}}/{{.GITHUB_SLUG}})" ]]'
      - test -d .git
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: 'The `.description` in `package.json` must be set.'
      - sh: '[ "{{.GITHUB_SLUG}}" != "null" ]'
        msg: 'The `.name` in `package.json` must be set.'
      - sh: '[ "{{.HOMEPAGE}}" != "null" ]'
        msg: 'The `.homepage` in `package.json` must be set.'

  github:update:
    deps:
      - github:update:meta

  github:update:meta:
    deps:
      - :install:software:gh
      - :install:software:jq
      - github:create
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      HOMEPAGE:
        sh: jq -r '.homepage' package.json
      PRIVATE:
        sh: jq -r '.private' package.json | sed 's/null/false/'
    env:
      OPTIONAL_TAGS:
        sh: jq '.keywords' .common/files-{{.REPOSITORY_SUBTYPE}}/package.json.handlebars
      TOPICS:
        sh: jq '.keywords' package.json | sed 's/null/[]/'
      TOPICS_LENGTH:
        sh: jq -r '.keywords | length' package.json
    cmds:
      - >
        if [ ! -z "$GITHUB_TOKEN" ]; then
          gh api -X PATCH repos/{owner}/{repo} -f description="{{.DESCRIPTION}}" -f homepage="{{.HOMEPAGE}}" \
            -f has_issues={{.GITHUB_ISSUES}} -f has_wiki={{.GITHUB_WIKI}} -f private="{{.PRIVATE}}" --silent
          RESULT="$TOPICS"
          if [ "$TOPICS_LENGTH" -gt 20 ]; then
            function updateList() {
              REMOVE_KEY="$(jq -n --argjson optional "$OPTIONAL_TAGS" '$optional['"$1"']')"
              RESULT="$(jq -n --argjson remove "$REMOVE_KEY" --argjson jq "$RESULT" '$jq | del(.[] | select(. == $remove))')"
            }
            LOOP_COUNT="$((TOPICS_LENGTH-20))"
            for i in $(seq "$LOOP_COUNT"); do
              updateList "$i"
            done
          fi
          MINIMIZED_TOPICS="$(jq -n --argjson tags "$RESULT" '$tags | .[]' | xargs | sed 's/ /","/g' | sed 's/^/"/' | sed 's/$/"/')"
          if [[ "$MINIMIZED_TOPICS" != '""' ]]; then
            curl -X PUT -H "Accept: application/vnd.github.mercy-preview+json" -u "{{.GITHUB_ORG}}:$GITHUB_TOKEN" \
              https://api.github.com/repos/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}/topics -d '{"names":['"$MINIMIZED_TOPICS"']}'
          fi
        else
          true warn 'The `GITHUB_TOKEN` environment variable is not set so the GitHub repository cannot be updated via the API.'
        fi
    status:
      - '[ -z "$GITHUB_TOKEN" ]'
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: 'The `.description` in `package.json` must be set.'
      - sh: '[ "{{.HOMEPAGE}}" != "null" ]'
        msg: 'The `.homepage` in `package.json` must be set.'

  gitlab:create:
    deps:
      - :install:software:glab
      - :install:software:jq
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITLAB_PATH:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/https:\/\/gitlab.com\///'
      GITLAB_GROUP:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/https:\/\/gitlab.com\///' | sed 's!/[^/]*$!!'
      NAME:
        sh: jq -r '.blueprint.name' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo '--private'; else echo '--public'; fi
      TMP:
        sh: mktemp
    env:
      KEYWORDS:
        sh: jq -r '.keywords | tostring' package.json | sed 's/\[//' | sed 's/\]//'
    run: once
    cmds:
      - ignore_error: true
        cmd: >
          if [ ! -z "$GITLAB_TOKEN" ] && ! glab repo view '{{.GITLAB_PATH}}' > /dev/null; then
            glab repo create '{{.GITLAB_PATH}}' --group '{{.GITLAB_GROUP}}' --description '{{.DESCRIPTION}}' --name '{{.NAME}}' \
              {{.PROJECT_TYPE}} --tag '$KEYWORDS'
          else
            true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab repository cannot be created.'
          fi
    status:
      - glab repo view {{.GITLAB_PATH}}
      - test -d .git
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: 'The `.description` in `package.json` must be set.'
      - sh: '[ "{{.NAME}}" != "null" ]'
        msg: 'The `.blueprint.name` variable in `package.json` must be set.'

  gitlab:mirror:
    deps:
      - :install:software:glab
      - :install:software:jq
      - github:create
      - gitlab:create
    vars:
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      GITLAB_REPO_ID:
        sh: glab api projects/:fullpath | jq -r '.id'
      PUSH_MIRROR_COUNT:
        sh: glab api projects/:fullpath/remote_mirrors | jq '. | length'
    cmds:
      - >
        if [[ "{{.PUSH_MIRROR_COUNT}}" == '0' ]]; then
          glab api projects/:fullpath/remote_mirrors --method POST --header "Content-Type: application/json" \
            -f "url=https://{{.GITHUB_USER}}:$GITHUB_TOKEN@github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}.git" \
            -f 'enabled=true'
        fi
      - cmd: >
          curl -H 'Content-Type: application/json' -H "Authorization: Bearer $GITLAB_TOKEN" -XPUT --data \
            "{'mirror': true, 'import_url': 'https://{{.GITHUB_USER}}:$GITHUB_TOKEN@github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}.git'}" \
            'https://gitlab.com/api/v4/projects/{{.GITLAB_REPO_ID}}'
    sources:
      - package.json
    preconditions:
      - sh: '[ ! -z "$GITHUB_TOKEN" ]'
        msg: 'The `GITHUB_TOKEN` environment variable must be set to enable mirroring.'
      - sh: '[ ! -z "$GITLAB_TOKEN" ]'
        msg: 'The `GITLAB_TOKEN` environment variable must be set to enable mirroring.'
      - sh: '[ ! -z "{{.GITLAB_REPO_ID}}" ]'
        msg: 'Unable to acquire `GITLAB_REPO_ID`. Ensure origin is pointing to GitLab.'

  gitlab:pipelines:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      PIPELINE_COUNT:
        sh: jq -r '.gitlab_pipelines | length' .variables.json
    env:
      PIPELINES:
        sh: jq -r '.gitlab_pipelines' .variables.json
      PIPELINE_RES:
        sh: glab api projects/:fullpath/pipeline_schedules
    cmds:
      - >
        if [ ! -z "$GITLAB_TOKEN" ]; then
          for INDEX in {1..{{.PIPELINE_COUNT}}}; do
            PIPELINE_INDEX="$((INDEX - 1))"
            ACTIVE="$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].active')"
            CRON="$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].cron' | sed 's/"//g')"
            DESC="$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].description')"
            REF="$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].ref')"
            if ! echo "$PIPELINE_RES" | grep "$DESC"; then
              glab api projects/:fullpath/pipeline_schedules -X POST -f active="$ACTIVE" -f description="$DESC" \
                -f ref="$REF" -f cron="$CRON" -f cron_timezone='{{.TIMEZONE}}' --silent
              true success 'Pipeline with description of `$DESC` successfully added'
            else
              true log 'Pipeline with description of `'"$DESC"'` already added'
            fi
          done
        else
          true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab pipelines cannot be updated via the API.'
        fi
    status:
      - '[ -z "$GITLAB_TOKEN" ]'
    sources:
      - .variables.json

  gitlab:pipelines:clear:
    env:
      PIPELINE_IDS:
        sh: glab api projects/:id/pipeline_schedules -X GET | jq -r '.[].id'
    cmds:
      - >
        for ID in "$PIPELINE_IDS"; do
          glab api projects/:fullpath/pipeline_schedules/"$ID" -X DELETE
        done

  gitlab:update:
    deps:
      - gitlab:mirror
      - gitlab:pipelines
      - gitlab:update:meta
      - gitlab:wiki

  gitlab:update:meta:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      NAME:
        sh: jq -r '.blueprint.name' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo 'private'; else echo 'public'; fi
    env:
      KEYWORDS:
        sh: jq -r '.keywords | tostring' package.json | sed 's/\[//' | sed 's/\]//'
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          glab api projects/:fullpath -X PUT -f description="{{.DESCRIPTION}}" -f name="{{.NAME}}" \
            -f wiki_enabled={{.GITLAB_WIKI}} -f visibility="{{.PROJECT_TYPE}}" -f tag_list="$KEYWORDS" --silent
        else
          true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab repository cannot be updated via the API.'
        fi
    status:
      - '[ -z "$GITLAB_TOKEN" ]'
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: 'The `.description` in `package.json` must be set.'
      - sh: '[ "{{.NAME}}" != "null" ]'
        msg: 'The `.blueprint.name` variable in `package.json` must be set.'

  gitlab:wiki:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      DOCS_URL:
        sh: jq -r '.docs.link' .variables.json
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          glab api projects/:fullpath/services/external-wiki -X PUT -f external_wiki_url="{{.DOCS_URL}}" --silent
        else
          true warn 'The `GITLAB_TOKEN` environment variable is not set so the GitLab repository external wiki cannot be updated via the API.'
        fi
    status:
      - '[ -z "$GITLAB_TOKEN" ]'
    sources:
      - .variables.json
    preconditions:
      - sh: '[ "{{.DOCS_URL}}" != "null" ]'
        msg: 'The `.docs.link` variable in `.variables.json` must be set.'
      - sh: '[ "{{.GROUP}}" != "null" ]'
        msg: 'The `.group` variable in `.variables.json` must be set.'

  remotes:
    deps:
      - :install:software:git
    desc: 'Configure the git remote `origin` to point to GitLab and the git remote `all` to point to GitLab and GitHub'
    summary: |
      # Configure git remote

      This task will set the origin to the GitLab repository associated with this project. It will then also create
      a remote named `all` which will point to both the GitLab repository and the GitHub mirror. You can then
      push to both repositories at the same time by running `git push origin master`.

      **Example usage:**
      `task git:remotes`
    vars:
      GITHUB_REPO:
        sh: jq -r '.blueprint.repository.github' package.json | sed 's/^https:\/\//git@/' | sed 's/github.com\//github.com:/'
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/^https:\/\//git@/' | sed 's/gitlab.com\//gitlab.com:/'
    cmds:
      - |
        if [ ! -z '{{.GITLAB_REPO}}' ]; then
          if git config remote.origin.url; then
            git remote set-url origin '{{.GITLAB_REPO}}.git'
          else
            git remote add origin '{{.GITLAB_REPO}}.git'
          fi
          if git config remote.gitlab.url; then
            git remote set-url gitlab '{{.GITLAB_REPO}}.git'
          else
            git remote add gitlab '{{.GITLAB_REPO}}.git'
          fi
        fi
      - |
        if [ ! -z '{{.GITHUB_REPO}}' ]; then
          if git config remote.github.url; then
            git remote set-url github '{{.GITHUB_REPO}}.git'
          else
            git remote add github '{{.GITHUB_REPO}}.git'
          fi
        fi
      - |
        if [ ! -z '{{.GITLAB_REPO}}' ] && [ ! -z '{{.GITHUB_REPO}}' ]; then
          if git config remote.all.url; then
            git remote rm all
          fi
          git remote add all '{{.GITLAB_REPO}}.git'
          git remote set-url --add --push all '{{.GITHUB_REPO}}.git'
          git remote set-url --add --push all '{{.GITLAB_REPO}}.git'
        fi
    status:
      - '[ -z "{{.GITHUB_REPO}}" ]'
      - '[ -z "{{.GITLAB_REPO}}" ]'
    sources:
      - package.json

  remove:submodules:
    deps:
      - :install:software:git
    desc: Remove all submodules in the current directory and optionally filter by RegEx
    summary: |
      # Remove submodules in current directory

      This task will remove all the submodules in the current directory and its' children.
      You can optionally specify RegEx to only remove submodules that match a particular pattern.
      Please note that this task is not _perfect_. You should commit your current changes before using it
      and then reset the repository with `git reset --hard HEAD` if anything pops up on `git status` that
      you do not like after running it.

      **Example removing all submodules that are children of the working directory:**
      `task git:remove-submodules`

      **Example removing all submodules that are children of the working directory and matching a pattern:**
      `task git:remove-submodules -- docs`
    vars:
      GITMODULES_PATH: '.gitmodules'
      ROOT_GIT: # /home/hawkwood/Downloads/Backup/Code
        sh: git rev-parse --git-dir | sed 's/\.git\/modules\(.*\)/.gitmodules/' | sed 's/\.git$/.gitmodules/' | sed 's/.gitmodules$//'
      REGEX_ARG:
        sh: if [ -z "{{.CLI_ARGS}}" ]; then echo ""; else echo " | grep {{.CLI_ARGS}}"; fi
      RELATIVE_PATH:
        sh: pwd | sed "s,^$(git rev-parse --show-toplevel),," | cut -c2-
      TOP_LEVEL: # /home/hawkwood/Downloads/Backup/Code/docker/ci-pipeline/hadolint
        sh: git rev-parse --show-toplevel
    cmds:
      - |
        if [ -f '.gitmodules' ]; then
          MODULE_PATHS=$(git config --file "{{.GITMODULES_PATH}}" --name-only --get-regexp "{{.RELATIVE_PATH}}" |
            sed 's/^submodule\.//' | grep "path$" | sed 's/\.path$//'{{.REGEX_ARG}})
          for MODULE_PATH in "$MODULE_PATHS"; do
            # https://github.com/a14m/gitsubmodule/blob/master/gitsubmodule
            git config -f '{{.GITMODULES_PATH}}' --remove-section "submodule.$MODULE_PATH" | true
            git add '{{.GITMODULES_PATH}}'
            # /home/hawkwood/Downloads/Backup/Code/.git/modules/docker/ci-pipeline/hadolint/config
            {{if eq .ROOT_GIT ""}}
              CONFIG_PATH='.git'
            {{else}}
              CONFIG_PATH="$(pwd | sed 's,{{.ROOT_GIT}},,')"
            {{end}}
            git config -f '{{.ROOT_GIT}}./{{if ne .ROOT_GIT ""}}.git/modules/{{end}}'"$CONFIG_PATH"'/config' --remove-section "submodule.$MODULE_PATH"
            git rm --cached "$MODULE_PATH"
            rm -rf "{{.ROOT_GIT}}./.git/modules/$CONFIG_PATH"
            rm -rf "$MODULE_PATH"
          done
        else
          true info 'This task does not run unless there is a `.gitmodules` file in the current directory'
        fi
    status:
      - '! test -f .gitmodules'
