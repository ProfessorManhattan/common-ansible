---
version: '3'

tasks:
  all:
    deps:
      - ':{{if eq .REPOSITORY_TYPE "packer"}}packer:update:descriptions{{else}}donothing{{end}}'
      - files
      - :git:remotes
    cmds:
      - task: all:docs

  all:docs:
    deps:
      - contributing
      - readme

  ansible:
    deps:
      - :ansible:populate:dependencies
      - :ansible:populate:meta
      - :ansible:update:galaxy-id

  common:
    deps:
      - :install:software:git
    cmds:
      - |
        if [[ '{{.PRODUCTION_MODE}}' == 'true' ]]; then
          cd .common
          git reset --hard HEAD
          git pull origin master --no-rebase || true
          cd ..
        fi
    status:
      - '[[ "{{.PRODUCTION_MODE}}" != "true" ]]'

  contributing:
    deps:
      - :install:npm:prettier
      - :install:npm:readme
    vars:
      CONTRIB_TEMPLATE: .common/docs/blueprint-contributing.md
    cmds:
      - readme generate --silent --headingPrefix '{}' --config .variables.json --input "{{.CONTRIB_TEMPLATE}}" --output CONTRIBUTING.md
      - task: markdown:scrub
        vars:
          SCRUB_FILE: CONTRIBUTING.md
      - prettier --write CONTRIBUTING.md
    log:
      error: Failed to generate CONTRIBUTING.md
      start: Generating CONTRIBUTING.md
      success: Generated CONTRIBUTING.md
    sources:
      - CONTRIBUTING.md
      - .common/docs/**/*
      - .variables.json
    preconditions:
      - sh: test -f .common/docs/blueprint-contributing.md
        msg: The CONTRIBUTING.md template file is not present at `.common/docs/blueprint-contributing.md`
      - sh: test -f .variables.json
        msg: The `.variables.json` file is not present.
      - sh: type readme &> /dev/null
        msg: '`@appnest/readme` is not installed globally.'

  files:
    deps:
      - :install:npm:prettier
      - :install:software:git
      - :install:software:jq
      - :install:software:rsync
    vars:
      CONTAINER:
        sh: if [[ "${container:=}" == "docker" ]]; then echo "docker"; fi
      FIRST_LINE:
        sh: if [ -f Dockerfile ]; then head -n 1 Dockerfile; fi
      PKG_VERSION:
        sh: jq -r '.version' package.json
    env:
      PKG_BLUEPRINT:
        sh: jq -r '.blueprint' package.json | sed 's/^null$/{}/'
      PKG_DEPS:
        sh: jq -r '.dependencies' package.json | sed 's/^null$/{}/'
      PKG_DEV_DEPS:
        sh: jq -r '.devDependencies' package.json | sed 's/^null$/{}/'
      PKG_KEYWORDS:
        sh: jq -r '.keywords' package.json | sed 's/^null$/[]/'
      PKG_SCRIPTS:
        sh: jq -r '.scripts' package.json | sed 's/^null$/{}/'
      TMP:
        sh: mktemp
    cmds:
      - task: files:handlebars
      - find '.common/files-{{.REPOSITORY_SUBTYPE}}' -type f -name '*.handlebars' -delete
      - |
        {{if eq .REPOSITORY_SUBTYPE "ci-pipeline"}}
          if [[ "{{.FIRST_LINE}}" == *"debian"* ]] || [[ "{{.FIRST_LINE}}" == *"ubuntu"* ]]; then
            cp .common/initctl initctl
          fi
        {{end}}
      - rsync -aPq ".common/files-{{.REPOSITORY_SUBTYPE}}/" ./
      - task: :common:{{if eq .CONTAINER "docker"}}husky:ci{{else}}husky{{end}}
      - task: sort
      - jq --arg blueprint "$PKG_BLUEPRINT" --arg deps "$PKG_DEPS" --arg devDeps "$PKG_DEV_DEPS" --arg keywords "$PKG_KEYWORDS" --arg scripts
        "$PKG_SCRIPTS" --arg version "{{.PKG_VERSION}}" '.dependencies = (($deps | fromjson) * .dependencies) |
        .devDependencies = (($devDeps | fromjson) * .devDependencies) | .keywords = .keywords + ($keywords | fromjson) |
        .keywords = (.keywords | sort | unique) | .scripts = (($scripts | fromjson) * .scripts) | .blueprint = ($blueprint | fromjson) |
        .version = $version' package.json > "$TMP"
      - '{{.NPM_PROGRAM}} install --ignore-scripts'
      - mv "$TMP" package.json
      - prettier --write package.json
      - |
        if [[ '{{.PRODUCTION_MODE}}' == 'true' ]]; then
          cd .common && git reset --hard HEAD
          git clean -fd
          cd ..
        else
          cd .common
          git checkout -- files-{{.REPOSITORY_SUBTYPE}}/package.json.handlebars
        fi
      - task: :{{if eq .REPOSITORY_SUBTYPE "role"}}ansible:keywords:sync{{else}}donothing{{end}}
    sources:
      - Dockerfile
      - package.json
      - .variables.json
    preconditions:
      - sh: 'type rsync &> /dev/null'
        msg: '`rsync` is not installed!'

  files:handlebars:
    deps:
      - :install:npm:hbs
    env:
      TMP_BASENAME:
        sh: mktemp
      TMP_DIRNAME:
        sh: mktemp
    cmds:
      - |
        find ./.common/files-{{.REPOSITORY_SUBTYPE}} -type f -name '*.handlebars' | while read FILE; do
          hbs --data .variables.json "$FILE" --stdout > "${FILE%.*}"
        done
    sources:
      - .common/**/*.handlebars
      - .variables.json
    preconditions:
      - sh: 'type hbs &> /dev/null'
        msg: '`hbs-cli` is not installed globally.'

  init:
    cmds:
      - |
        if ! test -f package.json; then
          echo '{"blueprint": {}}' > package.json
        fi
      - |
        if ! test -f requirements.txt; then
          echo '' > requirements.txt
        fi
    status:
      - test -f package.json
      - test -f requirements.txt

  man-page:
    deps:
      - :install:local:modules
      - :install:npm:remark
      - :install:npm:prettier
      - :install:npm:readme
    desc: Build `man` page from the README.md file
    vars:
      MAN_TEMPLATE: '{{.REPOSITORY_SUBTYPE}}-blueprint-man.md'
    cmds:
      - |
        if test -f ".common/docs/{{.MAN_TEMPLATE}}"; then
          readme generate --headingPrefix '{}' --silent --config .variables.json --input ".common/docs/{{.MAN_TEMPLATE}}" --output CONTRIBUTING.md
          prettier --write MAN.md
          mkdir -p dist
          remark --use man MAN.md --output dist/man
          rm MAN.md
        fi
    log:
      error: Failed to generate MAN.md
    sources:
      - .common/docs/**/*
      - .variables.json
      - dist/man
    preconditions:
      - sh: test -f .variables.json
        msg: The `.variables.json` file is not present.

  markdown:scrub:
    vars:
      DIVIDER_SRC: <a href="\1" style="width:100%"><img style="width:100%"
        src="https://gitlab.com/megabyte-labs/assets/-/raw/master/png/aqua-divider.png" /></a>
      REGEX: .*https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/.*.png)][(]\(.*\)[)].*$
    cmds:
      - task: markdown:scrub:{{OS}}
        vars:
          DIVIDER_SRC: '{{.DIVIDER_SRC}}'
          REGEX: '{{.REGEX}}'
          SCRUB_FILE: '{{.SCRUB_FILE}}'

  markdown:scrub:darwin: sed -i .bak 's^{{.REGEX}}^{{.DIVIDER_SRC}}^g' {{.SCRUB_FILE}} && rm {{.SCRUB_FILE}}.bak

  markdown:scrub:linux: sed -i 's^{{.REGEX}}^{{.DIVIDER_SRC}}^g' {{.SCRUB_FILE}}

  modules:
    deps:
      - :install:software:git
    label: update:modules
    desc: Ensure all submodules in the `.modules/` folder are updated
    summary: |
      # Ensure all submodules in `.modules/` are updated

      Some of our projects include submodules. These submodules are generally
      stored in the `.modules/` folder in the root of the project. Some projects
      might symlink files to one of the submodules stored in the `.modules/` folder.
      If you are ok with the risk, you can use this task to update all the submodules
      to the latest on the remote's master branch.
    cmds:
      - |
        if ls .modules/*/ > /dev/null 2>&1; then
          for SUBMODULE_PATH in .modules/*/; do
            cd $SUBMODULE_PATH
            DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
            git reset --hard HEAD
            git checkout "$DEFAULT_BRANCH"
            git pull origin "$DEFAULT_BRANCH" --ff-only || true
          done
        fi
    status:
      - '! ls .modules/*/ > /dev/null 2>&1'

  project:
    cmds:
      - git pull origin master --no-rebase || true

  readme:
    deps:
      - ':{{if eq .REPOSITORY_TYPE "ansible"}}ansible:collection-dependencies:markdown{{else}}donothing{{end}}'
      - ':{{if eq .REPOSITORY_TYPE "ansible"}}ansible:mod-ansible-autodoc{{else}}donothing{{end}}'
      - :install:npm:prettier
      - :install:npm:readme
    vars:
      README_TEMPLATE: blueprint-readme-{{.REPOSITORY_SUBTYPE}}.md
    cmds:
      - readme generate --headingPrefix '{}' --silent --config .variables.json --input ".common/docs/{{.README_TEMPLATE}}"
      - task: markdown:scrub
        vars:
          SCRUB_FILE: README.md
      - task: ':{{if eq .REPOSITORY_TYPE "packer"}}packer:update:readme{{else}}donothing{{end}}'
      - prettier --write README.md
    log:
      error: Failed to generate README.md
      start: Generating README.md
      success: Generated README.md
    sources:
      - .autodoc/*
      - .common/docs/**/*
      - .variables.json
      - README.md
    preconditions:
      - sh: 'test -f .common/docs/{{.README_TEMPLATE}}'
        msg: 'The README.md template file is not present at `.common/docs/{{.README_TEMPLATE}}`.'
      - sh: test -f .variables.json
        msg: The `.variables.json` file is not present.

  repositories:
    cmds:
      - task: common
      - task: modules
      - task: project

  services:
    deps:
      - update
    label: update:services
    desc: Update elements of the repository that require API access
    summary: |
      # Update elements of the repository that require API access

      This task will ensure that the git repositories and other services related to the
      project are updated with the configurations.

      **Example usage:**
      `task common:update:services`
    cmds:
      - task: services:repos

  services:repos:
    deps:
      - :git:gitlab:update
      - :git:github:update
  sort:
    cmds:
      - if [ -f paths.txt ]; then sort paths.txt -o paths.txt; fi
      - if [ -f requirements.txt ]; then sort requirements.txt -o requirements.txt; fi
    sources:
      - paths.txt
      - requirements.txt

  start:
    deps:
      - :common:requirements
      - taskfile
      - variables

  taskfile:
    cmds:
      - |
        if [[ '{{.PRODUCTION_MODE}}' == 'true' ]]; then
          cp .common/files-{{.REPOSITORY_SUBTYPE}}/Taskfile.yml Taskfile.yml
        fi
    sources:
      - .common/files-{{.REPOSITORY_SUBTYPE}}/Taskfile.yml

  update:
    deps:
      - ':{{if eq .REPOSITORY_SUBTYPE "role"}}common:update:ansible{{else}}donothing{{end}}'
      - ':{{if eq .REPOSITORY_TYPE "packer"}}packer:latestos{{else}}donothing{{end}}'
      - init
      - repositories
    label: update
    desc: Refresh the project with the latest upstream code and ensure blueprint data has propagated
    summary: |
      # Refresh project with latest upstream code and ensure project files are up-to-date

      This task will pull the latest upstream code and overwrite any files that are out of date.
      Ideally, you should run this task often to ensure there are no merge conflicts and to
      ensure you are using the latest production settings. This task is also run by CI so
      normally if you pull the latest changes, you should already have the updates that this
      task applies.

      **Example usage:**
      `task update`
    run: once
    cmds:
      - task: start
      - task: all
      - task: ':{{if eq .REPOSITORY_TYPE "docker"}}docker:update-labels{{else}}donothing{{end}}'
      - task: update:git
    log:
      success: Successfully updated the project with the latest upstream changes

  update:git:
    cmds:
      - task: update:git:proceed
    status:
      - '[[ "${container:=}" == "docker" ]]'

  update:git:proceed:
    deps:
      - :git:github:update
      - :git:gitlab:update

  variables:
    deps:
      - :install:software:jq
    vars:
      SHARED_JSON: '.common/variables.{{.REPOSITORY_SUBTYPE}}.json'
    env:
      BLUEPRINT_DATA:
        sh: jq -r '.blueprint' package.json
      GITLAB_ENCODED_PATH:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/https:\/\/gitlab.com\///' | sed 's/\//%252F/g'
      TMP:
        sh: mktemp
    cmds:
      - echo hey
      - jq -S --arg blueprint "$BLUEPRINT_DATA" --arg encoded "$GITLAB_ENCODED_PATH" '. = . * ($blueprint | fromjson)
        | .gitlab_encoded_path = $encoded' '{{.SHARED_JSON}}' > "$TMP"
      - mv "$TMP" .variables.json
      - task: ':{{if eq .REPOSITORY_TYPE "packer"}}packer:update:variables{{else}}donothing{{end}}'
      - task: ':{{if eq .REPOSITORY_SUBTYPE "role"}}ansible:update:variables{{else}}donothing{{end}}'
    sources:
      - '{{.SHARED_JSON}}'
      - package.json
    preconditions:
      - sh: 'type jq &> /dev/null'
        msg: jq is not installed.
      - sh: 'type yq &> /dev/null'
        msg: yq is not installed.
