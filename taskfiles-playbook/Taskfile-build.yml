---
version: '3'

vars:
  TEMPLATE_FILE:
    sh: if [ ! -z "{{.CLI_ARGS}}" ]; then echo "{{.CLI_ARGS}}"; else echo "template.json"; fi

tasks:
  packer:all:
    deps:
      - :software:kvm
      - :software:packer
      - :software:parallels
      - :software:virtualbox
      - :software:vmware
    desc: Build Packer images for all platforms (default setting uses `template.json`)
    summary: |
      # Build Packer images for all virtualization platforms

      This task begins by removing cached files that may interfere with the Packer build
      process. It then runs `packer build template.json` if no arguments are passed. This
      command will build Packer images for all the virtualization platforms specified in
      the template file. The template file may include instructions for the following
      virtualization platforms (and it is possible that it includes other ones that are
      not listed below):

      * Hyper-V
      * KVM
      * Parallels
      * VMWare
      * VirtualBox

      If you would like to build machine images with another template then you can pass the
      template's file name as a parameter (see example below).

      **Example building on all platforms:**
      `task packer:all`

      **Example using a template file named `another_template.json`:**
      `task packer:all -- another_template.json`
    cmds:
      - task: prepare-packer
      - packer build {{.TEMPLATE_FILE}}

  docker:all:
    cmds:
      - task: normal
      - task: slim

  npm:all:
    deps: [main, module]

  npm:clean:
    deps:
      - :software:rsync
    desc: Remove temporary folders that might conflicts with builds
    vars:
      RANDOM_STRING:
        sh: openssl rand -hex 14
    cmds:
      - mv build /tmp/{{.RANDOM_STRING}}-build
      - mv test /tmp/{{.TEST_TMP}}-test
      - mkdir /tmp/{{.RANDOM_STRING}}-empty
      - |
        for TMP_FILE in build test; do
          if [ -f "/tmp/{{.RANDOM_STRING}}-$TMP_FILE" ] || [ -d "/tmp/{{.RANDOM_STRING}}-$TMP_FILE" ]; then
            (rsync -a --delete /tmp/{{.RANDOM_STRING}}-empty "/tmp/{{.RANDOM_STRING}}-$TMP_FILE" && rm -rf "/tmp/{{.RANDOM_STRING}}-$TMP_FILE") &
          fi
        done

  packer:kvm:
    deps:
      - :software:kvm
      - :software:packer
    desc: Build a Packer image for KVM
    summary: |
      # Build a Packer image for KVM

      This task will build a machine image intended to be used by KVM environments. KVM
      environments are generally only available on Linux (although, it is supposedly
      possible to run KVM on macOS as well). By default, this task assumes the template
      file is titled `template.json` and that the file is in the root of the project. If
      you would like to use another template file then you can do so by passing the file
      name as a parameter (see example below).

      **Example:**
      `task packer:kvm`

      **Example using a template file named `another_template.json`:**
      `task packer:kvm -- another_template.json`
    cmds:
      - task: prepare-packer
      - packer build -only=qemu {{.TEMPLATE_FILE}}

  npm:main:
    desc: Build `main` using `tsconfig.json`
    cmds:
      - tsc -p tsconfig.json

  npm:module:
    desc: Build `module` using `tsconfig.module.json`
    cmds:
      - tsc -p tsconfig.module.json

  man-page:
    desc: Build `man` page from the README.md file
    cmds:
      - echo "See https://github.com/remarkjs/remark-man"

  docker:fat:
    deps:
      - :software:docker
      - :software:jq
    desc: Build a Docker container from the Dockerfile
    summary: |
      # Build a Docker container from the Dockerfile

      This task builds a normal Docker container. It expects the Dockerfile to be
      named `Dockerfile` and for it to be in the root of the repository.

      For more information on building Docker containers, see [Docker's build guide](https://docs.docker.com/engine/reference/commandline/build/)
    vars:
      BUILD_DATE:
        sh: git show -s --format=%cI
      IMAGE_NAME: megabytelabs/
      REVISION:
        sh: git rev-parse HEAD
      VERSION:
        sh: jq -r '.version' package.json
    cmds:
      - true info "Building regular image named '{{.IMAGE_NAME}}'"
      - docker build --build-arg BUILD_DATE="{{.BUILD_DATE}}" --build-arg REVISION="{{.REVISION}}" --build-arg VERSION="{{.VERSION}}"
        --tag {{.IMAGE_NAME}}:latest --tag {{.IMAGE_NAME}}:{{.VERSION}} .
    sources:
      - Dockerfile
      - package.json

  packer:parallels:
    deps:
      - :software:packer
      - :software:parallels
    desc: Build a Packer image for Parallels
    summary: |
      # Build a Packer image for Parallels

      This task will build a machine image intended to be used by Parallels. Parallels
      is only available for macOS. By default, this task assumes the template file is
      titled `template.json` and that the file is in the root of the project. If you
      would like to use another template file then you can do so by passing the file
      name as a parameter (see example below).

      **Example:**
      `task packer:parallels`

      **Example using a template file named `another_template.json`:**
      `task packer:parallels -- another_template.json`
    cmds:
      - task: prepare-packer
      - packer build -only=parallels-iso {{.TEMPLATE_FILE}}

  docker:slim-finish:
    deps:
      - docker:slim-prettier
      - docker:slim-sizes

  docker:slim-prettier:
    deps:
      - :npm:prettier
    cmds:
      - prettier --write slim.report.json
    sources:
      - slim.report.json

  docker:slim-sizes:
    deps:
      - :software:docker
      - :software:jq
    vars:
      PREVIOUS_SLIM_SIZE:
        sh: jq -r '.blueprint.slim_size' package.json
      REGULAR_SIZE:
        sh: docker manifest inspect -v "{{.IMAGE_NAME}}:latest" | grep size | awk -F ":" "{sum+=$NF} END {print sum}"
          | awk "{$1=$1/(1024^2); print $1,'MB';}"
      SLIM_SIZE:
        sh: docker manifest inspect -v "{{.IMAGE_NAME}}:slim" | grep size | awk -F ":" "{sum+=$NF} END {print sum}"
          | awk "{$1=$1/(1024^2); print $1,'MB';}"
    env:
      TMP:
        sh: mktemp
    cmds:
      - true info "The slim build was compressed to '{{.SLIM_SIZE}}' ('{{.REGULAR_SIZE}}' originally)."
      - jq --arg a "{{.SLIM_SIZE}}" '.blueprint.slim_size = $a' package.json > "$TMP"
      - mv "$TMP" package.json
      - task: :common:update
    status:
      - '[[ "{{.PREVIOUS_SLIM_SIZE}}" == "{{.SLIM_SIZE}}" ]]'

  docker:slim:
    deps:
      - :common:npm-prettier
      - :software:docker
      - :software:dockerslim
    desc: Build a slim version of the Docker image
    summary: |
      # Build a compressed and secure container from the `regular` Docker image

      This task takes the Docker container generated by running `task build:normal` and
      compresses it using DockerSlim. Compressing it actually makes the container more
      secure too because there is a smaller attack surface with unnecessary tools and services
      removed.

      For more information, see [DockerSlim's GitHub page](https://github.com/docker-slim/docker-slim).
    vars:
      IMAGE_NAME: megabytelabs/
      SLIM_COMMAND:
        sh: jq -r '.blueprint.dockerslim_command' package.json
      VERSION:
        sh: jq -r '.version' package.json
    cmds:
      - |
        if ! docker image inspect megabytelabs/updater:latest > /dev/null 2>&1; then
          true info "Building regular image first"
          task build:normal
        fi
      - true info "Building slim image named '{{.IMAGE_NAME}}'"
      - docker-slim build --tag {{.IMAGE_NAME}}:slim {{.SLIM_COMMAND}} {{.IMAGE_NAME}}:latest
      - task: slim-finish
    sources:
      - Dockerfile
      - package.json
    preconditions:
      - sh: docker image inspect megabytelabs/updater:latest > /dev/null 2>&1
        msg: 'You need to build a normal Docker container before converting it into a slim build. Try running `task build:normal` before this task.'

  packer:virtualbox:
    deps:
      - :software:packer
      - :software:virtualbox
    desc: Build a Packer image for VirtualBox
    summary: |
      # Build a Packer image for VirtualBox

      This task will build a machine image intended to be used by VirtualBox. By
      default, this task assumes the template file is titled `template.json` and
      that the file is in the root of the project. If you would like to use another
      template file then you can do so by passing the file name as a parameter
      (see example below).

      **Example:**
      `task packer:virtualbox`

      **Example using a template file named `another_template.json`:**
      `task packer:virtualbox -- another_template.json`
    cmds:
      - task: prepare-packer
      - packer build -only=virtualbox-iso {{.TEMPLATE_FILE}}

  packer:vmware:
    deps:
      - :software:packer
      - :software:vmware
    desc: Build a Packer image for VMWare
    summary: |
      # Build a Packer image for VMWare

      This task will build a machine image intended to be used by VMWare. The image
      build can be used by either VMWare Workstation (i.e. Linux, Windows) or by
      VMWare Fusion (i.e. macOS). By default, this task assumes the template file is
      titled `template.json` and that the file is in the root of the project. If you
      would like to use another template file then you can do so by passing the file
      name as a parameter (see example below).

      **Example:**
      `task packer:vmware`

      **Example using a template file named `another_template.json`:**
      `task packer:vmware -- another_template.json`
    cmds:
      - task: prepare-packer
      - packer build -only=vmware-iso {{.TEMPLATE_FILE}}
